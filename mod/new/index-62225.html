<!-- GR8BRIK VERSION 6-15-2025 (SUBOBJECT AND TEXTURES BETA 3.0) -->
<!DOCTYPE html>
<html lang="en">
<head>
  <title>GR8BRIK Modeler</title>
  <meta charset="utf-8">
  <base href="/mod/new/">
  <meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
  <script src="https://code.jquery.com/jquery-3.7.1.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/stats.js/7/Stats.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/jszip@latest/dist/jszip.min.js" integrity="sha256-rMfkFFWoB2W1/Zx+4bgHim0WC7vKRVrq6FTeZclH1Z4=" crossorigin="anonymous"></script>
  <link rel="stylesheet" type="text/css" href="index.css?v=6152025_test1">
</head>

<body>
  <div id="top-container">
    <span id="link-home"><img src="/img/logo.jpg" id="logo-img" /><a href="/"><span>&nbsp;GR8BRIK&nbsp;</span></a><span class="tag">BETA</span></span>
    <a href="https://www.gr8brik.rf.gd/acc/login" id="username-field">Login</a>
  </div>

  <div id="info">
    <p"><a href="https://www.gr8brik.rf.gd/" target="_blank">GR8BRIK beta</a> - Build June 15th, 2025</p>
  </div>

  <script src="https://cdn.jsdelivr.net/npm/three@latest/build/three.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/three@latest/examples/js/loaders/LDrawLoader.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/three@latest/examples/js/controls/OrbitControls.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/three@latest/examples/js/controls/TransformControls.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/spectrum/1.8.1/spectrum.min.js"></script>
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/spectrum/1.8.1/spectrum.min.css" />
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.7.0/css/font-awesome.css">

  <button id="toggleMenu" class="mobile-toggle">&#x2630;</button>
  <button id="takeScreenshot" class="mobile-toggle" style="top: 155px; padding-right: 0px; padding-left: 0px;"><i class="fa fa-camera" aria-hidden="true" alt="screenshot"></i></button>
  <button id="getPriceInfo" class="mobile-toggle" style="top: 255px; padding-right: 0px; padding-left: 0px;"><i class="fa fa-money" aria-hidden="true" alt="get price info"></i></button>
  
  <div id="left-container">
    <p style="height: 2vh;"></p>
    
    <button class="btn" title="Settings for the modeler" id="settings-popup-open"><i class="fa fa-cog" aria-hidden="true"></i>Settings</button><br />
    <span>Progress</span><br />
    <button class="btn" title="Save creation data to database" id="save-popup-open"><i class="fa fa-database" aria-hidden="true"></i>Save to Cloud</button><br />
    <button id="import-popup-open" class="btn"><i class="fa fa-download" aria-hidden="true"></i>Import...</button>
    <button id="export-popup-open" class="btn"><i class="fa fa-upload" aria-hidden="true"></i>Export...</button><hr />
    
    <span>Edit tools</span><br />
    <button class="btn" title="Change controls to arrows to move blocks up and down, side-by-side." id="move-block-t"><i class="fa fa-arrows-alt" aria-hidden="true"></i>Drag</button>
    <button class="btn" title="Change controls to rotate blocks, in all directions." id="move-block-r"><i class="fa fa-refresh" aria-hidden="true"></i>Rotate</button><br />
    <button id="duplicate-part" class="btn" title="Copy the block that was last added and paste it"><i class="fa fa-files-o" aria-hidden="true"></i>Duplicate Block</button><br />
    <button id="delete-block" class="btn" title="Remove a block from the scene, along with all records of it"><i class="fa fa-trash" aria-hidden="true"></i>Delete Block</button><hr />

    <span>Color</span><br />
    <input type="text" id="color-picker" /><input type="number" id="selected-map" min="0" max="50" step="1" value="0"><hr />
    <span id="obj-colors"></span>

    <span>Filter</span><br />

    <select id="part-type-filter" style="display: inline-block;">
        <option value="brick" selected>Bricks</option>
        <option value="plate">Plates</option>
        <option value="baseplate">Baseplates</option>
        <option value="tile">Tiles</option>
        <option value="slope">Slopes</option>
        <option value="minifig">Minifigs</option>
        <option value="duplo">Duplo</option>
        <option value="animal">Animals</option>
        <option value="technic">Technic</option>
        <option value="wedge">Wedges</option>
        <option value="hinge">Hinges</option>
        <option value="clip_&_bar">Clips & Bars</option>
        <option value="connector">Connectors</option>
        <option value="wheel_&_tyre">Wheels & Tyres</option>
        <option value="train">Train Parts</option>
        <option value="panel">Panels</option>
        <option value="round_&_curved">Round & Curved</option>
        <option value="other">Miscellaneous</option>
    </select><br />

    <input type="text" id="search-parts" placeholder="search parts..." /><hr />

    <button id="tab1" class="tab-button">Add blocks</button>
    <button id="tab2" class="tab-button">Scene blocks</button><br /><br />
    
	  <input type="file" id="cre-import" accept=".json,.gr8" style="display: none;"><input type="file" id="cre-import-three" accept=".json" style="display: none;">
	  <span id="cre-export" style="display: none;"></span><span id="cre-export-gr8" style="display: none;"></span><span id="cre-export-ldd" style="display: none;"></span><span id="cre-export-three" style="display: none;"></span><span id="cre-export-dae" style="display: none;"></span>

    <span id="select-block"></span>
    <ul id="block-list">
      <div class="warn">GR8BRIK treats some items as groups</div>
    </ul>
  </div>

  <div id="save-popup">
    <button class="btn-alt" style="float: right; top: 0;">&#10006;</button>
    <h3><span style="color: #fff;">Save Creation</span></h3>
    <div id="save-popup-form">
      <p><input class="w3-input w3-border" type="text" name="name" placeholder="Name"></p>
      <p><textarea name="desc" rows="4" cols="32" placeholder="Description"></textarea></p>
      <p><button class="btn" title="Finish saving" id="download-json">Save Creation</button></p>
    </div>
  </div>
  
  <div id="import-popup">
    <button class="btn-alt" style="float: right; top: 0;">&#10006;</button>
    <h3><span style="color: #fff;">Import Model</span></h3>
    <div id="import-popup-form">
		<select id="import-format" style="display: inline-block;">
			<option value="cloud" selected>From account</option>
			<option value="json">GR8BRIK</option>
			<option value="three">ThreeJS</option>
		</select><br />
		<p><button class="btn" title="Finish importing" id="import-finish">Select file</button></p>
    </div>
  </div>
  
  <div id="export-popup">
    <button class="btn-alt" style="float: right; top: 0;">&#10006;</button>
    <h3><span style="color: #fff;">Export Model</span></h3>
    <div id="export-popup-form">
		<select id="export-format" style="display: inline-block;">
      <option value="gr8">GR8BRIK (.gr8)</option>
			<option value="json">GR8BRIK (.json)</option>
			<option value="three">ThreeJS (.json)</option>
			<option value="lxf">Lego Digital Designer (.lxf)</option>
			<option value="dae">Collada (.dae)</option>
		</select><br />
		<p><button class="btn" title="Finish exporting" id="export-finish">Download file</button></p>
    </div>
  </div>

  <div id="settings-popup">
    <button class="btn-alt" style="float: right; top: 0;">&#10006;</button>
    <h3><span style="color: #fff;">Modeler Settings</span></h3>
    <input type="checkbox" id="smooth-normals-enable" checked>
    <label for="smooth-normals">Enable smooth normals</label>
		<p><button class="btn" title="Finish editing settings" id="settings-finish">Save</button></p>
    </div>
  </div>

  <div id="preloaded-logo">
    <div class="img"></div>
  </div>

  <script>
    window.addEventListener('beforeunload', function (e) {
        e.preventDefault();
        e.returnValue = '';
    });

    var partColor = "#C91A09";
    const start_url = 'https://gr8brik.rf.gd';
	
	document.addEventListener("DOMContentLoaded", function () {
	
		// fix links not working
		document.addEventListener('click', function (event) {
			if (event.target.tagName === 'A') {
				event.preventDefault();
				const url = event.target.getAttribute("href");
				if (event.target.hasAttribute("download")) return;
				if (url && /^https?:\/\//.test(url)) {
					window.location.href = url;
				}
			}
		});
		
		// user login function
		// todo have this run ever 10 seconds if user is not signed in
		function login() {
			fetch(start_url + "/ajax/user.php?ajax=true")
				.then(res => res.json())
				.then(response => {
          if(response.success) {
            const field = document.getElementById("username-field");
            //field.style.display = "inline";
            field.innerText = response.user;
            field.setAttribute("href", "/acc/creations");
            tooltip('Logged in as ' + response.user);
          }
				})
				.catch(async (err) => {
					try {
						const res = await err.response.json();
						tooltip(res.error);
						console.error("Login error:", res.error);
					} catch {
						tooltip('An unknown error occurred while logging in');
					}
				});
		}
		login();
		
		let displayed_parts = [];
		let current_type = '';
		let cached_parts = {};
		
		// load parts from url
		function loadParts(type) {
			console.log(`loading ${type} category`);
			current_type = type;

			if (cached_parts[type]) {
				console.log(`${type} parts loaded from cache`);
				displayed_parts = cached_parts[type];
				displayParts();
				return;
			}

			fetch(`https://susstevedev.github.io/gr8brik-new/parts/${type}.json`)
				.then(res => res.json())
				.then(data => {
					console.log(`${type} parts loaded`);
					displayed_parts = data;
					cached_parts[type] = data;
					displayParts();
				})
				.catch(err => {
					console.error('error loading parts ', err);
					tooltip('Failed to load parts');
				});
		}
		
		// display parts function
		function displayParts() {
			const container = document.getElementById("select-block");
			container.innerHTML = '';
			displayed_parts.forEach(part => {
				const span = document.createElement("span");
				span.id = part.file;
        span.title = part.name;
				span.setAttribute("value", part.file);
				span.innerHTML = `
					<img src="https://library.ldraw.org/images/library/official/parts/${part.file.split(".")[0]}.png" loading="lazy" width="45px" />
					<br />
					<small class="part-list-number">${part.file.split(".")[0]}</small>
					&nbsp;
					<!-- <small class="hover-only">${part.name}</small> -->
				`;
				container.appendChild(span);
			});
		}
		
		loadParts('brick');
		
		// search function
		document.getElementById("search-parts").addEventListener("keyup", function (event) {
			if (event.key === "Enter") {
				const value = this.value.toLowerCase().replace(/\s+/g, " ").trim();
				const items = Array.from(document.querySelectorAll("#select-block span"));

				items.forEach(item => {
					//const text = item.textContent.toLowerCase().replace(/\s+/g, " ").trim();
          const text = (item.title || "").toLowerCase().replace(/\s+/g, " ").trim();
					item.style.display = text.includes(value) ? 'flex' : 'none';
				});
			}
		});

    // hover effects
    document.querySelectorAll("#select-block span").forEach(function (elm) {
        elm.addEventListener("mouseover", function (event) {
            alert('test');
        });
    });
		
		// add a new block
		document.getElementById("select-block").addEventListener("click", function (e) {
			const span = e.target.closest("span");
			
			if (!span) {
				return;
			}
			
			const selectedPart = span.getAttribute("value");
			
			if (!selectedPart) {
				console.error("selected part is not valid");
				return;
			}
			
			part = 'parts/' + selectedPart;
			partName = selectedPart;
			console.log("selected piece:", selectedPart);
			addBlock();
		});
		
		// list for items that are already in the scene
		document.querySelector("#block-list").addEventListener("click", function (e) {
			if (e.target.matches(".scene-block-item")) {
				const id = e.target.getAttribute("data-id");
				const obj = scene.getObjectByProperty('uuid', id);
				if (obj) {
					transformControls.detach(selectedObject);
					selectedObject = null;
					transformControls.attach(obj);
					selectedObject = obj;
					tooltip('Part selected');
				}
			}
		});
		
		// save creation
		document.getElementById("download-json").addEventListener("click", function () {
			const sceneJSON = generateSceneJSON();
			if (sceneJSON) {
				const jsonData = sceneJSON;
				const date = new Date();
				date.setTime(date.getTime() + (365 * 24 * 60 * 60 * 1000));
				document.cookie = "localsave=" + btoa(jsonData) + "; expires=" + date.toUTCString();

				const name = document.querySelector("#save-popup input[name='name']").value.trim();
				const desc = document.querySelector("#save-popup textarea[name='desc']").value.trim();
				const screenshot = capture();
				
				this.innerHTML = `<i class="fa fa-spinner fa-spin" aria-hidden="true"></i>`;

				fetch(start_url + "/ajax/build.php", {
					method: "POST",
					headers: { "Content-Type": "application/x-www-form-urlencoded" },
					body: new URLSearchParams({
						save_build: true,
						creation: jsonData,
						name,
						desc,
						screenshot
					})
				})
				.then(res => res.json())
				.then(response => {
					tooltip(response.success);
					this.innerText = "Save Creation";
					this.disabled = true;
				})
				.catch(async err => {
					try {
						const res = await err.response.json();
						tooltip(res.error);
						this.innerText = "Try again";
					} catch {
						tooltip("An unknown error occurred.");
						this.innerText = "Try again";
					}
				});
			} else {
				tooltip('Problem while generating scene');
			}
		});
		
		// import modal
		document.getElementById("import-finish").addEventListener("click", function () {
			const format = document.getElementById("import-format").value;
			if(format === "cloud") {
				tooltip('GR8BRIK models from your account cannot be imported yet.');
				return;
			}
			if(format === "three") {
				document.getElementById("cre-import-three").click();
			}
			if(format === "json") {
				document.getElementById("cre-import").click();
			}
			if(format === "lxf") {
				document.getElementById("cre-export-ldd").click();
			}
		});
		
		// export model
		document.getElementById("export-finish").addEventListener("click", function () {
			const format = document.getElementById("export-format").value;
			if(format === "three") {
				document.getElementById("cre-export-three").click();
			}
			if(format === "json") {
				document.getElementById("cre-export").click();
			}
      if(format === "gr8") {
				document.getElementById("cre-export-gr8").click();
			}
			if(format === "lxf") {
				document.getElementById("cre-export-ldd").click();
			}
			if(format === "dae") {
				const collada = new THREE.ColladaExporter();
				const collada_data = collada.parse(scene);
				const blob = new Blob([collada_data.data], { type: 'model/vnd.collada+xml' });
				const url = URL.createObjectURL(blob);
				const date = getDate();

				const a = document.createElement('a');
				a.href = url;
				a.download = `collada-${date}.dae`;
				a.click();

				setTimeout(() => {
					URL.revokeObjectURL(url);
				}, 10000);
			}
		});

		document.getElementById("part-type-filter").addEventListener("change", function () {
			loadParts(this.value);
		});
		
		// save to cloud menu open and close

		document.getElementById("save-popup-open").addEventListener("click", function () {
			document.getElementById("save-popup").style.display = "block";
		});

		document.querySelector("#save-popup .btn-alt").addEventListener("click", function () {
			document.getElementById("save-popup").style.display = "none";
		});
		
		// import popup open and close
		document.getElementById("import-popup-open").addEventListener("click", function () {
			document.getElementById("import-popup").style.display = "block";
		});

		document.querySelector("#import-popup .btn-alt").addEventListener("click", function () {
			document.getElementById("import-popup").style.display = "none";
		});
		
		// export popup open and close
		document.getElementById("export-popup-open").addEventListener("click", function () {
			document.getElementById("export-popup").style.display = "block";
		});

		document.querySelector("#export-popup .btn-alt").addEventListener("click", function () {
			document.getElementById("export-popup").style.display = "none";
		});

    // settings popup open and close
		document.getElementById("settings-popup-open").addEventListener("click", function () {
			document.getElementById("settings-popup").style.display = "block";
		});

		document.querySelector("#settings-popup .btn-alt").addEventListener("click", function () {
			document.getElementById("settings-popup").style.display = "none";
		});

	});


	// comment mess
    $(document).ready(function () {

      /*$(document).on('click', 'a', function(event) { 
			event.preventDefault();
			if ($(this).attr("download")) { 
				return;
			}
       
			let url = $(this).attr("href");
			if (url && url.match("^http" || "^https")) {
				window.location.href = url;
			}
      }); */

      /*function login() {
          $.ajax({
            url: start_url + "/ajax/user.php",
            method: "GET",
            data: {
                ajax: true
            },
            success: function (response) {
                $("#username-field").show().text(response.user);
                $("#username-field").attr("href", "/acc/creations");
                tooltip('Logged in as ' + response.user);
            },
            error: function (jqXHR, textStatus, errorThrown) {
            try {
              var response = JSON.parse(jqXHR.responseText);
              console.error('Error logging in: ' + textStatus + ' ' + jqXHR.status + ' ' + errorThrown);
              if (response && response.error) {
                console.error('Error logging in: ' + response.error);
                tooltip(response.error);
              }
            } catch (e) {
              console.error('Failed to parse error: ', e);
              console.error('Raw: ', jqXHR.responseText);
              tooltip('An unknown error occured while logging in');
            }
          }
          });
      }
      login(); */

      /*let displayed_parts = [];
      let current_type = '';
	  let cached_parts = {};

      function loadParts(type) {
        console.log(`loading ${type} category`);
		current_type = type;
		
		if (cached_parts[type]) {
			console.log(`${type} parts loaded from cache`);
			displayed_parts = cached_parts[type];
			displayParts();
			return;
		}

        $.ajax({
          url: `https://susstevedev.github.io/gr8brik-new/parts/${type}.json`,
          method: 'GET',
          dataType: 'json',
          success: function (data) {
            console.log(`${type} parts loaded`);
            displayed_parts = data;
			cached_parts[type] = data;
            displayParts();
          },
          error: function (err) {
            console.error('error loading parts ', err);
            tooltip('Failed to load parts');
          }
        });
      } */
	  
	 /*function displayParts() {
		let appended = '';
		displayed_parts.forEach(part => {
			appended += `<span id="${part.file}" value="${part.file}"><img src="https://library.ldraw.org/images/library/official/parts/${part.file.split(".")[0]}.png" loading="lazy" width="45px" /><br /><small class="part-list-number">${part.file.split(".")[0]}</small>&nbsp;<small class="hover-only">${part.name}</small></span>`;
		});
		$('#select-block').html(appended);
	} */

      /*$('#part-type-filter').on('change', function () {
        let selectedType = $(this).val();
        loadParts(selectedType);
      }); */

      //loadParts('brick');

      /*$(document).on("click", "#select-block span", function () {
        let selectedPart = $(this).attr("value");
        if (!selectedPart) {
          console.error("selected part is not valid");
          return;
        }

        part = 'parts/' + selectedPart;
        partName = selectedPart;
        console.log("selected peice: ", selectedPart);
        addBlock();
      }); */

      /*$(document).on("click", "#save-popup .btn-alt", function () {
        $("#save-popup").hide();
      });

      $(document).on("click", "#save-popup-open", function () {
        $("#save-popup").fadeIn();
      }); */

      /*$(document).on("click", "#download-json", function () {
		let original_text = "Save Creation";
		
        let sceneJSON = generateSceneJSON();

        if (sceneJSON) {
          const jsonData = sceneJSON;
          console.log(jsonData);

          const date = new Date();
          date.setTime(date.getTime() + (365 * 24 * 60 * 60 * 1000));
          document.cookie = "localsave=" + btoa(jsonData) + "; expires=" + date
            .toUTCString() + "";

          let name = $("#save-popup input[name='name']").val().trim();
          let desc = $("#save-popup textarea[name='desc']").val().trim();
          let screenshot = capture();

          $.ajax({
            url: start_url + "/ajax/build.php",
            type: "POST",
            data: {
              save_build: true,
              creation: jsonData,
              name: name,
              desc: desc,
              screenshot: screenshot
            },
            success: function (response) {
              console.log(`OK: ${response.success}`);
              tooltip(response.success);
            },
            error: function (xhr, status, error) {
              try {
                var response = JSON.parse(xhr.responseText);
                console.error(`ERR: ${response.error} (${error}).`);
                tooltip(response.error);
              } catch (e) {
                console.error("Invalid error response:", xhr.responseText);
                tooltip("An unknown error occurred.");
              }
            }
          });
        }
      }); */

      /*$("#color-picker").spectrum({
        color: "#ff0000",
        preferredFormat: "hex",
        showInput: true,
        showPalette: true,
        maxSelectionSize: 4,
        palette: [
          ["#FF0000", "#00FF00", "#0000FF", "#FFFF00", "#00FFFF", "#FF00FF"],
          ["#000000", "#FFFFFF", "#808080", "#FFA500", "#800080", "#FFC0CB"],
          ["#A52A2A", "#FFD700", "#C0C0C0", "#8B0000", "#006400", "#00008B"],
          ["#C91A09", "#A0BCAC", "#7789A5", "#958A73", "#A3A2A4", "#635F61"]
        ],
        change: function (color) {
          console.log(`Changed selected color to ${color.toName() || color.toHexString()}`);
          partColor = color.toHexString();
          if (color && selectedObject) {
            changeBlockColor(color.toHexString());
          }
        }
      }); */

      $("#color-picker").spectrum({
        color: partColor,
        preferredFormat: "hex",
        showInput: true,
        showPalette: true,
        maxSelectionSize: 4,
        palette: [
          [
            "#C91A09", // Bright Red
            "#F8CC00", // Bright Yellow
            "#0020A0", // Bright Blue
            "#005700", // Dark Green
            "#FE8A18", // Bright Orange
            "#D941BB", // Bright Violet
          ],
          [
            "#000000", // Black
            "#FFFFFF", // White
            "#747371", // Dark Stone Grey (Dark Bluish Grey)
            "#A3A2A4", // Medium Stone Grey (Light Bluish Grey)
            "#958A73", // Dark Tan (Brick Yellow)
            "#6C5C4D", // Brown
          ],
          [
            "#812A00", // Dark Brown
            "#5883C1", // Medium Blue
            "#4B974B", // Sand Green
            "#A52A2A", // Dark Red
            "#B36D2C", // Dark Orange
            "#FCB7BC", // Bright Pink
          ],
          [
            "#60C0E0", // Bright Light Blue
            "#FBE696", // Earth Yellow (Light Yellow)
            "#84B68D", // Bright Green
            "#92B28B", // Lime Green
            "#002A5A", // Dark Blue
            "#DDDD22", // Vibrant Yellow
          ],
        ],
        change: function (color) {
          console.log(`Changed selected color to ${color.toName() || color.toHexString()}`);
          partColor = color.toHexString();
          if (color && selectedObject) {
            changeBlockColor(color.toHexString());
          }
        },
      });

      /*$("#search-parts").on("keyup", function () {
			if(event.which == 13) {
			  let value = $(this).val().toLowerCase().replace(/\s+/g, " ").trim();
			  let list = $("#select-block span");

			  list.sort(function (a, b) {
				  let textA = $(a).text().toLowerCase().replace(/\s+/g, " ").trim();
				  let textB = $(b).text().toLowerCase().replace(/\s+/g, " ").trim();

				  let matchA = textA.indexOf(value) > -1 ? 0 : 1;
				  let matchB = textB.indexOf(value) > -1 ? 0 : 1;

				  return matchA - matchB;
			  });

			  $("#select-block").html(list);
			  list.each(function () {
				  let text = $(this).text().toLowerCase().replace(/\s+/g, " ").trim();
				  //$(this).toggle(text.indexOf(value) > -1);
				  if (text.indexOf(value) > -1) {
					$(this).css('display', 'flex');
				} else {
					$(this).css('display', 'none');
				}
			  });
			}
      });*/

      /*$(document).on("click", ".scene-block-item", function () {
        let id = $(this).data("id");
		  
		if(scene.getObjectByProperty('uuid', id)) {
			part = scene.getObjectByProperty('uuid', id);
			
			transformControls.detach(selectedObject);
			selectedObject = null;
			
			transformControls.attach(part);
            selectedObject = part;
            tooltip('Part selected');
		}
		});  */
    });
  </script>
  <script>
	const three_version = '0.176.0';
    const studSize = 1000;
    let partList = document.getElementById('blk');
    let colList = document.getElementById('select-color');
	
	/*import * as THREE from `https://cdn.jsdelivr.net/npm/three@${three_version}/build/three.module.js`;
	window.THREE = THREE;
	
	import { OBJExporter } from `https://cdn.jsdelivr.net/npm/three@${three_version}/examples/jsm/exporters/OBJExporter.js`; */

    document.getElementById("username-field").addEventListener("click", function () {
      var content = document.getElementById("username-content");
      if (content.style.display === "block" || content.style.display === "") {
        content.style.display = "none";
      } else {
        content.style.display = "block";
      }
    });

    document.getElementById("color-picker").addEventListener("click", function () {
      console.log("color picker clicked");
    });

    document.getElementById("duplicate-part").addEventListener("click", function () {
      if(selectedObject) {
        duplicatePart();
      }
    });

    document.getElementById("selected-map").addEventListener("input", function () {
      console.log(`Selected material number is ${this.value}`);
      selectedMap = this.value;
    });
	
	document.getElementById("delete-block").addEventListener("click", function () {
		deleteBlock(selectedObject);
	});

    document.getElementById("takeScreenshot").addEventListener("click", function () {
      let url = capture();
      let date = getDate();
      let a = document.createElement("a");

      a.href = url;
      a.download = `creation-screenshot-${date}.PNG`;
      a.click();
    });

    document.getElementById("toggleMenu").addEventListener("click", function () {
      var left = document.getElementById("left-container");
      if (left.style.left === "0px" || left.style.left === "") {
        left.style.left = "-999px";
      } else {
        left.style.left = "0px";
      }
    });

    document.querySelectorAll('.tab-button').forEach(button => {
      button.addEventListener('click', function () {
        const is1 = this.id === 'tab1';
        var search = document.getElementById("search-parts");
        document.getElementById('select-block').style.display = is1 ? 'flex' :
          'none';
        document.getElementById('block-list').style.display = is1 ? 'none' :
          'block';
        search.readOnly = is1 ? false : true;
      });
    });
	
	document.getElementById("cre-export").addEventListener("click", () => {
        const jsonData = generateSceneJSON();
		const jsonBlob = new Blob([jsonData], { type: "application/json" });
		const elm = this;
		
		const url = URL.createObjectURL(jsonBlob);
		const date = getDate();
		const a = document.createElement("a");
		a.href = url;
		a.download = `json-creation-${date}.json`;
		a.click();
			
		setTimeout(() => {
			URL.revokeObjectURL(url);
		}, 10000);
  });

  document.getElementById("cre-export-gr8").addEventListener("click", () => {
    const fileData = generateSceneJSON();
		const dataBlob = new Blob([fileData], { type: "application/json" });
		const elm = this;
		
		const url = URL.createObjectURL(dataBlob);
		const date = getDate();
		const a = document.createElement("a");
		a.href = url;
		a.download = `gr8brik-creation-${date}.gr8`;
		a.click();
			
		setTimeout(() => {
			URL.revokeObjectURL(url);
		}, 10000);
  });
	
	document.getElementById("cre-export-ldd").addEventListener("click", () => {
		console.log('clicked');
        const legoData = generateSceneLXFML();
		const zip = new JSZip();
		zip.file("IMAGE100.LXFML", legoData);
		const elm = this;
		
		zip.generateAsync({ type: "blob" }).then(function (blob) {
			const url = URL.createObjectURL(blob);
			const date = getDate();
			
			const a = document.createElement("a");
			a.href = url;
			a.download = `ldd-creation-${date}.lxf`;
			a.click();
			
			URL.revokeObjectURL(url);
		});
    });
	
	document.getElementById("cre-export-three").addEventListener("click", () => {
		if (!scene) {
			tooltip("Scene is empty");
			return;
		}

		const date = getDate();
		const json = scene.toJSON();
		const jsonString = JSON.stringify(json);
		const blob = new Blob([jsonString], { type: "application/json" });
		const url = URL.createObjectURL(blob);

		const a = document.createElement("a");
		a.href = url;
		a.download = `threejs-${date}.json`;
		a.click();
		URL.revokeObjectURL(url);
	});


    /*document.getElementById("importBtn").addEventListener("click", function () {
      document.getElementById("cre-import").click();
    }); */

    document.getElementById("cre-import").addEventListener("change", function (event) {
        let file = event.target.files[0];
        if (!file) {
            console.error("No file selected");
            tooltip("No file selected.");
            return;
        }

        const reader = new FileReader();
        reader.onload = function (e) {
            try {
                const jsonData = JSON.parse(e.target.result);
                loadSceneFromJSON(jsonData);
            } catch (err) {
                tooltip("Invalid JSON file.");
                console.error(err);
            }
            event.target.value = "";
        };
        reader.readAsText(file);
    });
  
	  async function loadSceneFromJSON(data) {
		if (!data || !data.blocks || !Array.isArray(data.blocks)) {
			console.error("Invalid JSON data.");
			tooltip("Invalid JSON.");
			return;
		}

		for (const block of data.blocks) {
			partName = block.partName;
			partColor = '#' + block.color;
			partPosition = block.position;
			partRotation = block.rotation;

			part = 'parts/' + block.ldraw;

			try {
				await new Promise((resolve, reject) => {
					addBlock(resolve, reject);
				});
			} catch (err) {
				console.warn(`Failed to add block: ${block.partName}`, err);
				tooltip(`Failed to load ${block.partName}`);
			}
		}

		console.log("Creation imported.");
		tooltip("Creation imported.");
	}
	
	/*document.getElementById("import-btn-three").addEventListener("click", function () {
		document.getElementById("cre-import-three").click();
    }); */
	
	document.getElementById("cre-import-three").addEventListener("change", function (event) {
        let file = event.target.files[0];
        if (!file) {
            console.error("No file selected");
            tooltip("No file selected");
            return;
        }

        const reader = new FileReader();
		
        reader.onload = function (e) {
          try {				
            const data = JSON.parse(e.target.result);
            const loader = new THREE.ObjectLoader();

            let object;

            if (data.metadata && data.metadata.type && data.metadata.type === "App" && data.object) {
                object = loader.parse(data.object);
            } else {
                object = loader.parse(data);
            }
            
            object.children.forEach(function(child) {
              child.userData.noSnap = true;
              child.userData.isBlock = true;
              child.userData.partName = object.ldraw;
              child.ldraw = object.ldraw;
              scene.add(child);
            });
            
            if(selectedObject) {
              transformControls.detach(selectedObject);
              selectedObject = null;
            }
          } catch (err) {
            tooltip(`error: ${err}`);
            console.error(err);
          }
          event.target.value = "";
          updateSceneData();
        };
        reader.readAsText(file);
    });

    var container, camera, scene, renderer, lighting, controls, grid_helper, ldraw_loader, raycaster, mouse, partRotation, partPosition, selectedObject, customPosition, selectedMap = null;

    let blocks = [];
    let blockGroups = [];

    init();
    animate();

    function getCookie(name) {
        var cookies = document.cookie;
        var parts = cookies.split(name + "=");
        var cookieValue = null;
        if (parts.length == 2) {
            cookieValue = parts.pop().split(";").shift();
        }
        return cookieValue;
    }

    function toggleGlobalSnap() {
      if(scene.userData.noSnap === true) {
        scene.userData.noSnap = false;
      } else {
        scene.userData.noSnap = true;
      }
      scene.updateMatrixWorld(true);
    }

    // toggle smooth normals
    // todo make this actually work
    document.getElementById("smooth-normals-enable").addEventListener("click", function () {
      ldraw_loader.smoothNormals = this.checked;

      scene.traverse((child) => {
        if (child.isMesh && child.userData.isBlock && child.geometry) {
          child.geometry.computeVertexNormals();
          child.geometry.attributes.normal.needsUpdate = true;

          if (Array.isArray(child.material)) {
            child.material.forEach(mat => {
              mat.flatShading = !ldraw_loader.smoothNormals;
              mat.needsUpdate = true;
            });
          } else {
            child.material.flatShading = !ldraw_loader.smoothNormals;
            child.material.needsUpdate = true;
          }
        }
      });
      scene.updateMatrixWorld(true);
    });

    function isDark() {
        if(getCookie('mode')) {
          if(getCookie('mode') === 'dark') {
            return true;
          } else {
            return false;
          }
        } else {
          if(window.matchMedia("(prefers-color-scheme: dark)").matches) {
            return true;
          } else {
            return false;
          }
        }
    }

  function snapToGrid(value, gridSize) {
    return Math.round(value / gridSize) * gridSize;
  }
	
	function getDate() {
		const today = new Date();
		const yyyy = today.getFullYear();
		const mm = String(today.getMonth() + 1).padStart(2, '0');
		const dd = String(today.getDate()).padStart(2, '0');

		return `${yyyy}-${mm}-${dd}`;
	}

  function init() {
    // Scene container
    container = document.createElement('div');
    container.classList.add("scene");
    document.body.appendChild(container);

    // Scene
    scene = new THREE.Scene();
    scene.userData.noSnap = false;
    if(isDark()) {
			scene.background = new THREE.Color(0x252424);
		} else {
			scene.background = new THREE.Color(0xfafafa);
		}

    // WebGl renderer
    renderer = new THREE.WebGLRenderer({alpha: true});
    renderer.setSize(window.innerWidth, window.innerHeight);
    // set pixel ratio
    // @the_an0nym on mecabricks/discord/youtube pointed out how if your screen resolution isn't 100% (and in some cases just always), the scene looks buggy
    // https://discord.com/channels/1307420772377165884/1323840015087702026/1381346420535201998
    renderer.setPixelRatio(window.devicePixelRatio);
    container.appendChild(renderer.domElement);
		
    // Camera
    camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 10000);
    camera.position.set(250, 250, 250);
		
    // Lighting
		const ambient_lighting = new THREE.AmbientLight(0xdddddd, 1);
    scene.add(ambient_lighting);

		const directional_lighting = new THREE.DirectionalLight(0xdddddd, 1);
    directional_lighting.position.set(10, 15, 10);
    scene.add(directional_lighting);

    lighting = new THREE.DirectionalLight(0xffffff, 2);
    lighting.position.copy(camera.position);
    scene.add(lighting);

    transformControls = new THREE.TransformControls(camera, renderer.domElement);
    scene.add(transformControls);

    controls = new THREE.OrbitControls(camera, renderer.domElement);
    controls.enableDamping = true;
    controls.dampingFactor = 0.2;

    const stud_size = 20; // 1 stud = 20
    const grid_size = stud_size * 16; // studs wide
    const divisions = 16; // 1 division per stud
		
		if(isDark()) {
			grid_helper = new THREE.GridHelper(grid_size, divisions, 0x242424, 0xfafafa);
			scene.add(grid_helper);
		} else {
			grid_helper = new THREE.GridHelper(grid_size, divisions, 0xfafafa, 0x242424);
			scene.add(grid_helper);
		}

    const ldraw_path = "https://raw.githubusercontent.com/susstevedev/gr8brik-ldraw-fork/refs/heads/main/ldraw-parts/";
    ldraw_loader = new THREE.LDrawLoader();
    ldraw_loader.preloadMaterials(ldraw_path + 'colors/ldconfig.ldr');
    ldraw_loader.setPath(ldraw_path + 'actual/');
    ldraw_loader.setPartsLibraryPath(ldraw_path + 'actual/');
        
    raycaster = new THREE.Raycaster();
    mouse = new THREE.Vector2();

    window.addEventListener('keydown', function (event) {
      let activeElement = document.activeElement;

      if (activeElement.tagName === "INPUT" || activeElement.tagName === "TEXTAREA") {
        return;
      }

      switch (event.code) {
        case 'KeyT':
          moveBlock('t')
          break
        case 'KeyR':
          moveBlock('r')
          break
        case 'KeyS':
          moveBlock('s')
          break
        case 'Escape':
          deselect(selectedObject);
          break
        case 'Delete':
          deleteBlock(selectedObject);
          break
        case 'ArrowUp':
          selectedObject.rotation.x -= THREE.MathUtils.degToRad(45);
          break;
        case 'ArrowDown':
          selectedObject.rotation.x += THREE.MathUtils.degToRad(45);
          break;
        case 'ArrowLeft':
          selectedObject.rotation.y -= THREE.MathUtils.degToRad(45);
          break;
        case 'ArrowRight':
          selectedObject.rotation.y += THREE.MathUtils.degToRad(45);
          break;
        }
      })

      document.getElementById('move-block-t').addEventListener('click', function () {
        if (selectedObject) {
          moveBlock('t');
        }
      });

      document.getElementById('move-block-r').addEventListener('click', function () {
        if (selectedObject) {
          moveBlock('r');
        }
      });

      window.addEventListener('resize', onWindowResize, true);
      window.addEventListener('pointerdown', onMouseClick, true);

      transformControls.addEventListener('mouseDown', function () {
        controls.enabled = false;
      });

      transformControls.addEventListener('mouseUp', function () {
        controls.enabled = true;
      });

      transformControls.addEventListener('dragging-changed', function (event) {
        controls.enabled = !event.value;
      });

      transformControls.addEventListener('objectChange', function () {
        if (selectedObject && !(selectedObject.userData.noSnap || scene.userData.noSnap)) {
          selectedObject.position.set(
            snapToGrid(selectedObject.position.x, 10), 
            snapToGrid(selectedObject.position.y, 4), 
            snapToGrid(selectedObject.position.z, 10)
          );

          selectedObject.rotation.set(
            Math.round(selectedObject.rotation.x / THREE.MathUtils.degToRad(45)) * THREE.MathUtils.degToRad(45),
            Math.round(selectedObject.rotation.y / THREE.MathUtils.degToRad(45)) * THREE.MathUtils.degToRad(45),
            Math.round(selectedObject.rotation.z / THREE.MathUtils.degToRad(45)) * THREE.MathUtils.degToRad(45)
          );

          selectedObject.updateMatrixWorld(true);
          scene.updateMatrixWorld(true);
        }
        updateSceneData();
      });		
    }

    /*function changeBlockColor(color) {
      if (!selectedObject) {
        tooltip("No part selected");
        return;
      }

      selectedObject.traverse((child) => {
		//if (child.isMesh && child.material && !Array.isArray(child.material)) {
			child.material.color.set(color);
			child.material.needsUpdate = true;
		//}
      });

      console.log(`part color changed to ${color}`);
      tooltip(`Part color changed`);
    } */
	
	function changeBlockColor(color) {
		if (!selectedObject) {
			tooltip("No part selected");
			return;
		}

		selectedObject.traverse((child) => {
			if (child.isMesh && child.material) {
				if (Array.isArray(child.material)) {
          let mat;
          if (selectedMap != null) {
            if (child.material[selectedMap]) {
              mat = child.material[selectedMap];
            } else {
              selectedMap = null;
              tooltip('Invalid multi color map selected');
              return;
            }
          } else {
            mat = child.material[0];
          }

          if (mat && mat.color && !mat.map) {
            mat.color.set(color);
            mat.needsUpdate = true;
          }

          selectedMap = null;
          updateSceneData();
        } else if (child.material.color) {
					child.material.color.set(color);
					child.material.needsUpdate = true;
          updateSceneData();
				}
			}
		});

		console.log(`Part color changed to ${color}`);
		tooltip(`Part color changed to ${color}`);
	}

  function deleteBlock(part) {
    if (part) {
      if (part.isMesh) {
        if (part.parent) {
				  part.parent.remove(part);
				}
        part.updateMatrixWorld(true);
        tooltip('Deleted part');
      } else {
        tooltip('Part is not a valid mesh')
      }

      if (blockGroups && blockGroups.length > 0) {
        blockGroups.forEach(function (g) {
          g.remove(part);
          g.updateMatrixWorld(true);
        });
      }

      if (selectedObject === part) {
          deselect(part);
      }
  } else {
      tooltip('No part found');
  }
		scene.updateMatrixWorld(true);
		updateSceneData();
  }

  function capture() {
    let thumb = new THREE.Scene();
    thumb.background = null;

    let count = 0;

    scene.traverse(function (object) {
      if (object.isMesh) {
        let cloned = clone_mesh_clean(object);
        if (cloned) {
          thumb.add(cloned);
          if(object.userData.isBlock) {
            cloned.rotation.z += Math.PI;
            cloned.rotation.y += Math.PI;
          }
          console.log(cloned);
          count++;
        }
      }
    });

    if (count === 0) {
      console.warn("scene is empty");
      return null;
    }

    let light2 = new THREE.DirectionalLight(0xffffff, 1);
    light2.position.set(250, 250, 250);
    thumb.add(light2);

    let camera2 = camera.clone();

    let ambient2 = new THREE.AmbientLight(0xdddddd);
    thumb.add(ambient2);

    let renderer = new THREE.WebGLRenderer({ antialias: true, preserveDrawingBuffer: true });
    renderer.setClearColor(0x000000, 0); // transparent
    renderer.setSize(500, 500);
    renderer.render(thumb, camera2);

    let thumbnail = renderer.domElement.toDataURL("image/png");
    return thumbnail;
  }

  function makeid(length) {
      let result = '';
      const characters = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789';
      let counter = 0;

      while (counter < length) {
        result += characters.charAt(Math.floor(Math.random() * characters.length));
        counter += 1;
      }

      return result;
  }

    // Last cleaned up 6/2/2025 by susstevedev
  function addBlock(throwSuccess, throwError) {
        if (!ldraw_loader) {
            console.error('LdrawLoader is missing!');
            tooltip('Error setting LdrawLoader. Please refresh the page and try again.');
            return;
        }

        if (!part) {
            console.error('No part is selected!');
            tooltip('Please select a part.');
            return;
        }

        if (!partColor) {
            console.warn('Part color is not set! Setting color as white.');
            partColor = "#ffffff";
        }

        transformControls.detach(selectedObject);
        console.log("Loading part:", part);

        ldraw_loader.load(part, function (loadedGroup) {
            if (!loadedGroup) {
                console.error("Loaded group does not exist.");
                tooltip('Please select a block with valid mesh data');
                return;
            }

            let blockGroup = new THREE.Group();
            blockGroup.name = `ldraw_${makeid(10)}`;
            blockGroup.ldraw = part;
			
            loadedGroup.traverse((child) => {
              if (child.isMesh && !child.material.map && !child.isLineSegments && !Array.isArray(child.material)) {

                  child.material = new THREE.MeshPhysicalMaterial({
                    color: new THREE.Color(partColor || "#000000"),
                    roughness: 0.2,
                    metalness: 0.1,
                    reflectivity: 0.5,
                  });

                  child.userData.isBlock = true;
                  child.userData.isTexture = false;
                  child.userData.parentName = partName;
                  
                  transformControls.attach(child);
                  selectedObject = child;
              }
              
              if (child.isLineSegments) {
                child.visible = false;
              }

              if (child.material && child.material.map && child.isMesh && !child.isLineSegments) {
                child.userData.isBlock = true;
                child.userData.isTexture = true;
                child.userData.parentName = partName;
              }
            });

            blockGroup.add(loadedGroup);
              
            if(partPosition && partRotation) {
              blockGroup.position.set(partPosition.x, partPosition.y, partPosition.z);
              blockGroup.rotation.set(partRotation.x, partRotation.y, partRotation.z);
            } else {
              blockGroup.position.y = objectSize(blockGroup).y;
              blockGroup.rotation.x = Math.PI;
            }
              
            blockGroup.userData.partName = partName;
            scene.add(blockGroup);
              
            blocks.push(blockGroup);
            blockGroups.push(blockGroup);

            tooltip(`Added part ${part.replace("parts/", "")}`);

            /* const texturename = `${part.split("/").pop().split(".")[0]}.png`;
            const texturepath = `https://raw.githubusercontent.com/susstevedev/gr8brik-ldraw-fork/refs/heads/main/ldraw-parts/actual/parts/textures/${texturename}`;
            const texturepath = 'https://d1xez26aurxsp6.cloudfront.net/users/qXBby2/avatars/680a924dab4ba.png';
            const textureLoader = new THREE.TextureLoader();

            textureLoader.load(texturepath, (texturemap) => {
                texturemap.colorSpace = THREE.SRGBColorSpace;
                blockGroup.traverse(child => {
                    if (child.isMesh && child.material) {
                        child.material.map = texturemap;
                        child.material.needsUpdate = true;
                    }
                });
            }, undefined, (err) => {
                console.warn("Texture load failed or doesn't exist:", err);
            }); */

            updateBlockList(partName, partColor, blocks.length, blockGroup.uuid);
            updateSceneData();
            throwSuccess();
      }, undefined, function (error) {
          console.error('error loading piece:', error);
          throwError(error);
      });
  }

  function updateBlockList(part, color, count, id) {
    let blockList = document.getElementById('block-list');
    let listItem = document.createElement('li');

    listItem.classList.add('scene-block-item');
    listItem.setAttribute('data-id', id);
    listItem.textContent = `${part} (${color}, Num ${count})`;

    blockList.appendChild(listItem);
  }

  function subobjectPosition(g) {
      g.updateMatrixWorld(true);

      const position = new THREE.Vector3();
      const quaternion = new THREE.Quaternion();
      const scale = new THREE.Vector3();

      g.matrixWorld.decompose(position, quaternion, scale);

      const m = g.clone();

      m.position.copy(position);
      m.quaternion.copy(quaternion);
      m.scale.copy(scale);

      m.updateMatrix();
      return m;
  }
	
	function objectSize(obj) {
		if (!obj) {
			return new THREE.Vector3(0, 0, 0);
		}

		const b = new THREE.Box3().setFromObject(obj);
		const s = new THREE.Vector3();
		b.getSize(s);

		return s;
	}

  function isSmall(g, scale) {
    const boundingBox = new THREE.Box3().setFromObject(g);
    const size = new THREE.Vector3();
    boundingBox.getSize(size);

    return size.x < scale || size.y < scale || size.z < scale;
  }

  function generateUVMap(geometry) {
    geometry.computeBoundingBox();
    geometry.computeVertexNormals();

    const uvs = [];

    const position = geometry.attributes.position;
    const box = geometry.boundingBox;

    for (let i = 0; i < position.count; i++) {
      const x = position.getX(i);
      const y = position.getY(i);
      const u = (x - box.min.x) / (box.max.x - box.min.x);
      const v = (y - box.min.y) / (box.max.y - box.min.y);
      uvs.push(u, v);
    }

    geometry.setAttribute('uv', new THREE.Float32BufferAttribute(uvs, 2));
    return geometry;
  }

  function getPriceInfo() {
    if(selectedObject) {
      let part = selectedObject.parent.userData.fileName.replace("parts/", "").replace(".dat", "");

      fetch(`parts.php?part_price=true&part=${part}`)
        .then(res => res.json())
        .then(data => {
          const price = data.part_prices?.USD?.new;
          if (price !== undefined) {
            console.log("new price in united states dollars: $" + price);
          } else {
            console.warn(`price data unavailable for ${part}`);
          }
        });
		}
  }

  function duplicatePart() {
    if(selectedObject) {
      // I've never seen anyone use parent.parent but it works :D
      // Modern problems require modern solutions
      part = `parts/${selectedObject.userData.parentName}`;
      partName = selectedObject.userData.parentName;
      partColor = `#${selectedObject.material.color.getHexString().toLowerCase()}`;
      addBlock();
    }
  }
  
	function createGroup(gname, gelm) {
		let group = new THREE.Group();
    group.name = gname;
		group.add(gelm);
    return group;
	}

    /* function generateSceneJSON() {
      let sceneData = {
        blocks: []
      };

      if (selectedObject) {
          transformControls.detach(selectedObject);
          selectedObject = null;
      }

      blockGroups.forEach(function (group) {
        let group_color = null;
        console.log("blockGroups:", blockGroups);
          if (group) {
             group.traverse(function (child) {
              if (child && child.isMesh) {

                if (!child.material.map && !child.isLineSegments) {
                  group_color = child.material.color.getHexString().toLowerCase();
                }
              
                let blockData = {
                  partName: group.userData.partName,
                  color: group_color,
                  position: {
                    x: group.position.x,
                    y: group.position.y,
                    z: group.position.z
                  },
                  rotation: {
                    x: group.rotation.x,
                    y: group.rotation.y,
                    z: group.rotation.z
                  },
                  scale: {
                    x: group.scale.x,
                    y: group.scale.y,
                    z: group.scale.z
                  },
                  blockID: group.name,
                  ldraw: group.ldraw.replace("parts/", ""),
                };
                sceneData.blocks.push(blockData);
              }
             });
          }
      });
      return JSON.stringify(sceneData, null, 1);
    } */
  
    function generateSceneJSON() {
      //let sceneData = { metadata: {}, blocks: [], cameras: {}, lights: {} };

      let sceneData = {
        metadata: {
          file_version: 1.1,
          name: "My Model",
          description: null
        },
        camera: camera.clone().toJSON(),
        light: lighting.clone().toJSON(),
        blocks: []
      };

      if (selectedObject) {
        transformControls.detach(selectedObject);
        selectedObject = null;
      }

      blockGroups.forEach(function (group) {
        if (!group || !group.userData.partName) {
          return;
        }

        let group_color = null;
        let mesh_child = null;

        group.traverse(function (child) {
          if (child.isMesh) {
            // saving the child object because using the group itself doesn't work
            // todo update block groups in the updateSceneData() function
            // 6/14/2025
            mesh_child = child;
            mesh_color = child.material.color.getHexString().toLowerCase();
          }
        });

        const blockData = {
          partName: group.userData.partName,
          color: mesh_color,
          position: {
            x: mesh_child.position.x,
            y: mesh_child.position.y,
            z: mesh_child.position.z
          },
          rotation: {
            x: mesh_child.rotation.x + Math.PI,
            y: mesh_child.rotation.y,
            z: mesh_child.rotation.z
          },
          scale: {
            x: mesh_child.scale.x,
            y: mesh_child.scale.y,
            z: mesh_child.scale.z
          },
          blockID: group.name,
          ldraw: group.ldraw.replace("parts/", ""),
        };

        sceneData.blocks.push(blockData);
      });

      return JSON.stringify(sceneData, null, 2);
    }

    function generateSceneLXFML() {
      let sceneBricks = '';
      let boneRefs = [];
      let refID = 0;
      let totalPosition = new THREE.Vector3();
      let count = 0;

      if (selectedObject) {
        transformControls.detach(selectedObject);
        selectedObject = null;
      }

    const lego_color_map = {
      "C91A09": 21, // Bright Red
      "F8CC00": 24, // Bright Yellow
      "0020A0": 23, // Bright Blue
      "005700": 28, // Dark Green
      "FE8A18": 25, // Bright Orange
      "D941BB": 221, // Bright Violet

      "000000": 26, // Black
      "FFFFFF": 1, // White
      "747371": 199, // Dark Bluish Grey
      "A3A2A4": 208, // Light Bluish Grey
      "958A73": 2, // Brick Yellow
      "6C5C4D": 86, // Dark Brown

      "812A00": 120, // Reddish Brown
      "5883C1": 102, // Medium Blue
      "4B974B": 151, // Sand Green
      "A52A2A": 59, // Dark Red
      "B36D2C": 106, // Dark Orange
      "FCB7BC": 104, // Bright Pink

      "60C0E0": 107, // Bright Light Blue
      "FBE696": 103, // Light Yellow
      "84B68D": 37, // Bright Green
      "92B28B": 34, // Bright Yellowish Green
      "002A5A": 140, // Dark Blue
      "DDDD22": 334, // Vibrant Yellow (sometimes 24 is used)
    };

      blockGroups.forEach(function (group) {
        group.traverse(function (child) {
          if (child.isMesh) {
            totalPosition.add(group.position);
            count++;
          }
        });
      });

      blockGroups.forEach(function (group) {
        let mesh_child = null;
        group.traverse(function (child) {
          if (child.isMesh) {
            mesh_child = child;
          }
        });

        if (mesh_child) {
          let ldraw = group.ldraw.replace("parts/", "").replace(".dat", "");
          const boneID = refID;
          let colorID = 21;
            
          if(!mesh_child.material.map && !mesh_child.isLineSegments) {
            const hex = mesh_child.material.color.getHexString().toUpperCase();
            colorID = lego_color_map[hex] ?? 26;
          }
		 
          let adjustedMatrix = mesh_child.matrixWorld.clone();
          
          const globalrot = new THREE.Matrix4().makeRotationX(Math.PI / 1);
          adjustedMatrix.premultiply(globalrot);
          
          const flipmatrix = new THREE.Matrix4().makeRotationX(Math.PI);
          adjustedMatrix.multiply(flipmatrix);
          
          const translationMatrix = new THREE.Matrix4().makeTranslation(-20, 0, 0); // 1 LDU
          adjustedMatrix.multiply(translationMatrix);

          sceneBricks += `
            <Brick refID="${refID}" designID="${ldraw}" itemNos="${ldraw}">
              <Part refID="${refID}" designID="${ldraw}" materials="${colorID},0" decoration="0">
                <Bone refID="${refID}" transformation="${LXFMLMatrix(adjustedMatrix)}"></Bone>
              </Part>
            </Brick>`;

          boneRefs.push(boneID);
          refID++;
        }
      });

      const boneRefString = boneRefs.join(',');

      const sceneData = `
        <?xml version="1.0" encoding="UTF-8" standalone="no" ?>
        <LXFML versionMajor="5" versionMinor="0" name="Imported GR8BRIK Creation">
          <Meta>
            <Application name="LEGO Digital Designer" versionMajor="4" versionMinor="3"/>
            <Brand name="LDD"/>
            <BrickSet version="2670"/>
          </Meta>
		  <Model name="Imported GR8BRIK Creation"></Model>
          <Cameras>
            <Camera refID="0" fieldOfView="80" distance="120" transformation="1,0,0,0,1,0,0,0,1,0,0,120"/>
          </Cameras>
          <Bricks cameraRef="0">
            ${sceneBricks}
          </Bricks>
          <RigidSystems>
            <RigidSystem>
              <Rigid refID="0" transformation="1,0,0,0,1,0,0,0,1,0,0,0" boneRefs="${boneRefString}"/>
            </RigidSystem>
          </RigidSystems>
          <GroupSystems>
            <GroupSystem></GroupSystem>
          </GroupSystems>
          <BuildingInstructions></BuildingInstructions>
        </LXFML>
      `;

      return sceneData.replace(/\s+/g, ' ').trim();
    }

    function LXFMLMatrix(matrix4) {
      const unit = 0.04;
      const converted = matrix4.clone();
	  
	    const rotx = new THREE.Matrix4().makeRotationX(Math.PI / 1);
	  
	    const rot = new THREE.Matrix4();
	    rot.multiply(rotx);
      converted.premultiply(rot);

      const position = new THREE.Vector3();
      const quaternion = new THREE.Quaternion();
      const scale = new THREE.Vector3();
      converted.decompose(position, quaternion, scale);

      position.multiplyScalar(unit);
	    position.x -= 0.8;
	  
      converted.compose(position, quaternion, scale);
      const elm = converted.transpose().elements;

      return [
        elm[0], elm[4], elm[8],    // X
        elm[1], elm[5], elm[9],    // Y
        elm[2], elm[6], elm[10],   // Z
        elm[3], elm[7], elm[11]    // position
      ].map(v => v.toFixed(10)).join(',');
    }

    function updateSceneData() {
	    if (blockGroups && blockGroups.length > 0) {
        blockGroups.forEach(function (g) {
			    g.updateMatrixWorld(true);
          let hasTinyMesh = false;

          g.traverse(function (child) {
				    child.updateMatrixWorld(true);
              if (child.isMesh && isSmall(child, 19)) {
                hasTinyMesh = true;
              }
          });

          g.userData.noSnap = hasTinyMesh;

          if (!g.userData.noSnap || !scene.userData.noSnap) {
            g.position.set(
                snapToGrid(g.position.x, 10),
                snapToGrid(g.position.y, 4),
                snapToGrid(g.position.z, 10)
            );
          }
        });
		    scene.updateMatrixWorld(true);
      }
	  
      if (selectedObject) {
          selectedObject.updateMatrixWorld(true);
      }
  }

  /* 
  Clone mesh data and not anything like transform controls because idk how to remove it
  */
  function clone_mesh_clean(obj) {
      if (!obj.isMesh) { 
        return null;
      }

      const mat = obj.material.clone();
      const geometry = obj.geometry.clone();

      const obj_clone = new THREE.Mesh(geometry, mat);
      obj_clone.position.copy(obj.position);
      obj_clone.rotation.copy(obj.rotation);
      obj_clone.scale.copy(obj.scale);
      obj_clone.name = obj.name;

      return obj_clone;
  }

  /* function updateMaterials() {
    if(!selectedObject) {
      return;
    }

    displayedColors = document.getElementById("obj-colors");
    displayedColors.innerHTML = "";

		selectedObject.traverse((child) => {
			if (child.isMesh && child.material) {
				if (Array.isArray(child.material)) {
          child.material.forEach((mat, index) => {
            console.log(mat);
            if (mat && mat.color instanceof THREE.Color && typeof mat.color.getHexString === "function") {
              const colorHex = `#${mat.color.getHexString()}`;
              const span = document.createElement("span");
              console.log(`Subpart ${index}: ${colorHex}`);
              span.style.backgroundColor = colorHex;
              span.style.padding = "2px 2px 2px 2px";
              displayedColors.appendChild(span);
            }
          });
				}
			}
		});
    updateSceneData();
  } */

    function onMouseClick(event) {
        let target = event.target;
        let container = document.querySelector(".scene");
        const rect = container.getBoundingClientRect();
 
        if (!container.contains(target)) {
            return;
        }

        mouse.x = ((event.clientX - rect.left) / rect.width) * 2 - 1;
        mouse.y = -((event.clientY - rect.top) / rect.height) * 2 + 1;
 
        raycaster.setFromCamera(mouse, camera);
        let intersects = raycaster.intersectObjects(scene.children.filter(obj => obj.visible), true);

        if (intersects.length > 0) {
            selectObject(intersects[0].object);
        } else {
            deselect(selectedObject);
        }
     }
 
     function selectObject(obj) {
        while (obj.parent && !obj.userData.isBlock) {
            obj = obj.parent;
        }
 
        if (!obj.userData.isBlock && transformControls.enabled) {
            return;
        }
 
        if (obj === selectedObject) {
            return;
        }

        transformControls.detach(selectedObject);
		    selectedObject = null;
        
        transformControls.attach(obj);
		    selectedObject = obj;
        
        /* partColor = `#${obj.material.color.getHexString()}`;
        $("#your-color-input").spectrum("set", partColor); */
    }

    function deselect(obj) {
      transformControls.detach(obj);
		  selectedObject = null;
    }

    function onWindowResize() {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
    }

    function moveBlock(mode) {
        if (mode === "t") {
            transformControls.setMode('translate');
            tooltip('Changed to drag blocks');
        }

        if (mode === "r") {
            transformControls.setMode('rotate');
            tooltip('Changed to rotate blocks');
        }

        if (mode === "s") {
            transformControls.setMode('scale');
            tooltip('Changed to secret scale blocks');
        }
    }

    // Last refactor 6/3/2025 by susstevedev
    function animate() {
      document.addEventListener('DOMContentLoaded', function () {
        const stats = new Stats();

        stats.domElement.style.position = 'absolute';
        stats.domElement.style.zIndex = '99999999';
        stats.domElement.style.left = '0px';
        stats.domElement.style.bottom = '0px';
        document.body.appendChild(stats.domElement);

        setInterval(function () {
          stats.update();
        }, 1000 / 60);
      });

      requestAnimationFrame(animate);
      controls.update();
      lighting.position.copy(camera.position);
      renderer.render(scene, camera);
      renderer.outputColorSpace = THREE.SRGBColorSpace;
    }

    function tooltip(text) {
        const tooltip = document.createElement('div');

        tooltip.textContent = text;
        tooltip.setAttribute('id', 'tooltip');
        document.body.appendChild(tooltip);

        if (tooltip) {
            setTimeout(() => {
				      tooltip.style.animation = 'toright 0.5s ease-out forwards';
				      setTimeout(() => {
					      tooltip.remove();
				      }, 500);
            }, 5000);
        }
    }

    window.onload = function() {
        setTimeout(() => {
            if (document.getElementById("preloaded-logo")) {
                document.getElementById("preloaded-logo").style.display = "none";
            }
        }, 1000);
    }
  </script>

  <!-- LDRAW.ORG CC BY 2.0 PARTS LIBRARY ATTRIBUTION -->
  <div class="ldraw-logo">
        <a href="http://www.ldraw.org">
            <img style="width: 145px" src="https://threejs.org/examples/models/ldraw/ldraw_org_logo/Stamp145.png">
        </a>
    <br />
    <a href="http://www.ldraw.org/" style="color:#000;">This software uses the LDraw Parts Library</a>
  </div>

</body>
</html>