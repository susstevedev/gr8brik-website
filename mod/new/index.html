<!-- GR8BRIK VERSION 7-17-2025 (SUBOBJECT AND TEXTURES BETA 3.3.2) -->
<!DOCTYPE html>
<html lang="en">
<head>
  <title>Modeler - GR8BRIK</title>
  <meta charset="utf-8">
  <base href="/mod/new/">
  <meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">

  <script src="https://code.jquery.com/jquery-3.7.1.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/stats.js/7/Stats.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/jszip@latest/dist/jszip.min.js" integrity="sha256-rMfkFFWoB2W1/Zx+4bgHim0WC7vKRVrq6FTeZclH1Z4=" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/three@latest/build/three.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/three@latest/examples/js/loaders/LDrawLoader.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/three@latest/examples/js/controls/OrbitControls.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/three@latest/examples/js/controls/TransformControls.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/spectrum/1.8.1/spectrum.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/three@latest/examples/js/loaders/RGBELoader.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/three@0.127.0/examples/js/exporters/GLTFExporter.js"></script>
  <script src="https://cdn.jsdelivr.net/gh/susstevedev/gr8brik/lib/ColladaExporter-modded.js?v=6262025_test3"></script>
  <script src="https://cdn.jsdelivr.net/gh/GitHubDragonFly/GitHubDragonFly.github.io/viewers/static/js/exporters/OBJExporter.js?v=762025_test1"></script>
  
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/spectrum/1.8.1/spectrum.min.css" />
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.7.0/css/font-awesome.css">
  <link rel="stylesheet" type="text/css" href="index.css?v=742025_test2">
</head>

<body>
  <div id="top-container">
    <span id="link-home"><img src="/img/logo.jpg" id="logo-img" /><a href="/" target="_blank"><span>&nbsp;GR8BRIK&nbsp;</span></a><span class="tag">BETA</span></span>
    <a href="https://www.gr8brik.rf.gd/acc/login" target="_blank" id="username-field">Login</a>
  </div>

  <div id="info">
    <p><a href="https://www.gr8brik.rf.gd/" target="_blank">GR8BRIK beta</a> - Build July 17th, 2025</p>
  </div>

  <button id="toggleMenu" class="mobile-toggle">&#x2630;</button>
  <button id="takeScreenshot" class="mobile-toggle" style="top: 155px; padding-right: 0px; padding-left: 0px;"><i class="fa fa-camera" aria-hidden="true" title="Take a screenshot"></i></button>
  <button id="getPriceInfo" class="mobile-toggle" style="top: 255px; padding-right: 0px; padding-left: 0px;"><i class="fa fa-money" aria-hidden="true" title="Get price info"></i></button>
  <button id="resetCamera" class="mobile-toggle" style="top: 355px; padding-right: 0px; padding-left: 0px;"><i class="fa fa-refresh" aria-hidden="true" title="Reset the camera location"></i></button>
  
  <div id="left-container">
    <p style="height: 2vh;"></p>
    
    <button class="btn" title="Settings for the modeler" id="settings-popup-open"><i class="fa fa-cog" aria-hidden="true"></i>Settings</button><br />
    <span>Progress</span><br />
    <button class="btn" title="Save creation data to database" id="save-popup-open"><i class="fa fa-database" aria-hidden="true"></i>Save to Cloud</button><br />
    <button id="import-popup-open" class="btn"><i class="fa fa-download" aria-hidden="true"></i>Import...</button>
    <button id="export-popup-open" class="btn"><i class="fa fa-upload" aria-hidden="true"></i>Export...</button><hr />
    
    <span>Edit tools</span><br />
    <button class="btn" title="Change controls to arrows to move blocks up and down, side-by-side." id="move-block-t"><i class="fa fa-arrows-alt" aria-hidden="true"></i>Drag</button>
    <button class="btn" title="Change controls to rotate blocks, in all directions." id="move-block-r"><i class="fa fa-refresh" aria-hidden="true"></i>Rotate</button><br />
    <button id="duplicate-part" class="btn" title="Copy the block that was last added and paste it"><i class="fa fa-files-o" aria-hidden="true"></i>Duplicate Block</button><br />
    <button id="delete-block" class="btn" title="Remove a block from the scene, along with all records of it"><i class="fa fa-trash" aria-hidden="true"></i>Delete Block</button><hr />

    <span>Color</span><br />
    <input type="text" id="color-picker" /><input type="number" title="Selected material layer. Most textured LDraw parts have more than three layers." id="selected-map" min="0" max="50" step="1" value="0"><hr />
    <span id="obj-colors"></span>

    <span>Filter</span><br />

    <select id="part-type-filter" style="display: inline-block;">
        <option value="brick" selected>Bricks</option>
        <option value="plate">Plates</option>
        <option value="baseplate">Baseplates</option>
        <option value="tile">Tiles</option>
        <option value="slope">Slopes</option>
        <option value="minifig">Minifigs</option>
        <option value="duplo">Duplo</option>
        <option value="animal">Animals</option>
        <option value="technic">Technic</option>
        <option value="wedge">Wedges</option>
        <option value="hinge">Hinges</option>
        <option value="clip_&_bar">Clips & Bars</option>
        <option value="connector">Connectors</option>
        <option value="wheel_&_tyre">Wheels & Tyres</option>
        <option value="train">Train Parts</option>
        <option value="panel">Panels</option>
        <option value="round_&_curved">Round & Curved</option>
        <option value="other">Miscellaneous</option>
    </select><br />

    <input type="text" id="search-parts" placeholder="search parts..." /><hr />

    <button id="tab1" class="tab-button">Parts list</button>
    <button id="tab2" class="tab-button">Parts in scene</button><br /><br />
    
	  <input type="file" id="cre-import" accept=".json,.gr8" style="display: none;"><input type="file" id="cre-import-three" accept=".json" style="display: none;"><input type="file" id="cre-import-ldr" accept=".ldr,.dat" style="display: none;">
	  <span id="cre-export" style="display: none;"></span><span id="cre-export-gr8" style="display: none;"></span><span id="cre-export-ldd" style="display: none;"></span><span id="cre-export-three" style="display: none;"></span><span id="cre-export-dae" style="display: none;"></span>

    <span id="select-block"></span>
    <ul id="block-list">
      <div class="warn">GR8BRIK treats some items as groups</div>
    </ul>
  </div>

  <div id="save-popup">
    <button class="btn-alt" style="float: right; top: 0;">&#10006;</button>
    <h3><span style="color: #fff;">Save Creation</span></h3>
    <div id="save-popup-form">
      <p><input class="w3-input w3-border" type="text" name="name" placeholder="Name"></p>
      <p><textarea name="desc" rows="4" cols="32" placeholder="Description"></textarea></p>
      <p><button class="btn" title="Finish saving" id="download-json">Save Creation</button></p>
    </div>
  </div>
  
  <div id="import-popup">
    <button class="btn-alt" style="float: right; top: 0;">&#10006;</button>
    <h3><span style="color: #fff;">Import Model</span></h3>
    <div id="import-popup-form">
		<select id="import-format" style="display: inline-block;">
			<option value="cloud" selected>From account</option>
			<option value="json">GR8BRIK (.json, .gr8)</option>
			<option value="three">ThreeJS (.json)</option>
      <option value="ldr">Ldraw (.ldr, .dat, .mpd)</option>
		</select><br />
		<p><button class="btn" title="Finish importing" id="import-finish">Select file</button></p>
    </div>
  </div>
  
  <div id="export-popup">
    <button class="btn-alt" style="float: right; top: 0;">&#10006;</button>
    <h3><span style="color: #fff;">Export Model</span></h3>
    <div id="export-popup-form">
		<select id="export-format" style="display: inline-block;">
      <option value="gr8">GR8BRIK (.gr8)</option>
			<option value="json">GR8BRIK (.json)</option>
      <option value="mpd">Ldraw (.mpd)</option>
			<option value="three">ThreeJS (.json)</option>
			<option value="lxf">Lego Digital Designer (.lxf)</option>
			<option value="dae">Collada (.dae)</option>
      <option value="obj">Wavefront (.obj)</option>
      <option value="glb">GL Transmission Format (.gltf)</option>
		</select><br />
		<p><button class="btn" title="Finish exporting" id="export-finish">Download file</button></p>
    </div>
  </div>

  <div id="settings-popup">
    <button class="btn-alt" style="float: right; top: 0;">&#10006;</button>
    <h3><span style="color: var(--ui-text-color);">Modeler Settings</span></h3>
    <input type="checkbox" id="smooth-normals-enable" checked>
    <label for="smooth-normals-enable">Enable smooth normals</label><br />
    <input type="checkbox" id="display-lines-enable">
    <label for="display-lines-enable">Enable lines on objects</label><br />

    <hr />

		<button class="btn" title="Load autosave from device" onclick="read_autosave();"><i class="fa fa-floppy-o" aria-hidden="true"></i>Recover Autosave</button><br />
    <button class="btn" title="Clear autosave from device" onclick="clear_autosave();"><i class="fa fa-trash" aria-hidden="true"></i>Trash Autosave</button><br />
    </div>
  </div>

  <div id="preloaded-logo">
    <div class="img"></div>
  </div>

  <script>
    window.addEventListener('beforeunload', function (e) {
        e.preventDefault();
        e.returnValue = '';
    });

    var partColor = "#C91A09";
    const start_url = 'https://gr8brik.rf.gd';
	
	document.addEventListener("DOMContentLoaded", function () {
	
		// fix links not working
		document.addEventListener('click', function (event) {
			if (event.target.tagName === 'A') {
				event.preventDefault();
				const url = event.target.getAttribute("href");
				if (event.target.hasAttribute("download")) return;
				if (url && /^https?:\/\//.test(url)) {
					window.location.href = url;
				}
			}
		});
		
		// user login function
		// todo have this run ever 10 seconds if user is not signed in
		function login() {
			fetch(start_url + "/ajax/user.php?ajax=true")
				.then(res => res.json())
				.then(response => {
          if(response.success) {
            const field = document.getElementById("username-field");
            field.innerText = response.user;
            field.setAttribute("href", "/acc/creations");
            tooltip('Logged in as ' + response.user);
          }
				})
				.catch(async (err) => {
					try {
						const res = await err.response.json();
						tooltip(res.error);
						console.error("An error occured while authenticating " + res.error);
					} catch {
						tooltip('An error occured while authenticating');
					}
				});
		}
		login();
		
		let displayed_parts = [];
		let current_type = '';
		let cached_parts = {};
		
		// load parts from url
		function loadParts(type) {
			console.log(`loading ${type} category`);
			current_type = type;

			if (cached_parts[type]) {
				console.log(`${type} parts loaded from cache`);
				displayed_parts = cached_parts[type];
				displayParts();
				return;
			}

			fetch(`https://susstevedev.github.io/gr8brik/parts/${type}.json`)
				.then(res => res.json())
				.then(data => {
					console.log(`${type} parts loaded`);
					displayed_parts = data;
					cached_parts[type] = data;
					displayParts();
				})
				.catch(err => {
					console.error('error loading parts ', err);
					tooltip('Failed to load parts');
				});
		}
		
		// display parts function
		function displayParts() {
			const container = document.getElementById("select-block");
			container.innerHTML = '';
      displayed_parts = displayed_parts.sort((a, b) => a.name.length - b.name.length);

			displayed_parts.forEach(part => {
				const span = document.createElement("span");
				span.id = part.file;
        span.title = part.name;
				span.setAttribute("value", part.file);
				span.innerHTML = `
					<img src="https://library.ldraw.org/media/ldraw/official/parts/${part.file.split(".")[0]}.png?${Date.now()}" loading="lazy" width="45px" />
					<br />
					<small class="part-list-number">${part.file.split(".")[0]}</small>
					&nbsp;
					<!-- <small class="hover-only">${part.name}</small> -->
				`;
				container.appendChild(span);
			});
		}
		
		loadParts('brick');
		
		/*document.getElementById("search-parts").addEventListener("keyup", function (event) {
			if (event.key === "Enter") {
				const value = this.value.toLowerCase().replace(/\s+/g, " ").trim();
				const items = Array.from(document.querySelectorAll("#select-block span"));

				items.forEach(item => {
					//const text = item.textContent.toLowerCase().replace(/\s+/g, " ").trim();
          const text = (item.title || "").toLowerCase().replace(/\s+/g, " ").trim();
					item.style.display = text.includes(value) ? 'flex' : 'none';
				});
			}
		}); */

    /*document.getElementById("search-parts").addEventListener("keyup", function (event) {
      if (event.key === "Enter") {
        const value = this.value.toLowerCase().replace(/\s+/g, " ").trim();
        const items = Array.from(document.querySelectorAll("#select-block span"));

        items.forEach(item => {
          const titleText = (item.title || "").toLowerCase().replace(/\s+/g, " ").trim();
          const smallTextEl = item.querySelector("small.part-list-number");
          const smallText = smallTextEl ? smallTextEl.textContent.toLowerCase().trim() : "";

          const matches = titleText.includes(value) || smallText.includes(value);
          item.style.display = matches ? "flex" : "none";
        });
      }
    }); */

	// New search function
	// This will be slightly slower though as it stores an array of simi matching parts and exact matches for those parts, then goes through them and pushes the exact maches to the top
    document.getElementById("search-parts").addEventListener("keyup", function (event) {
      if (event.key === "Enter") {
        const value = this.value.toLowerCase().replace(/\s+/g, " ").trim();
        const items = Array.from(document.querySelectorAll("#select-block span"));

        const exact_match = [];
        const simi_match = [];

        items.forEach(item => {
          const title_txt = (item.title || "").toLowerCase().replace(/\s+/g, " ").trim();
          const part_num_elm = item.querySelector("small.part-list-number");
          const small_txt = part_num_elm ? part_num_elm.textContent.toLowerCase().trim() : "";

          const exact = title_txt === value || small_txt === value;
          const simi = title_txt.includes(value) || small_txt.includes(value);

          if (exact) {
            exact_match.push(item);
          } else if (simi) {
            simi_match.push(item);
          } else {
            item.style.display = "none";
          }
        });

        const container = document.getElementById("select-block");

        exact_match.concat(simi_match).forEach(item => {
          item.style.display = "flex";
          container.appendChild(item);
        });
      }
    });

    // hover effects
    document.querySelectorAll("#select-block span").forEach(function (elm) {
        elm.addEventListener("mouseover", function (event) {
            alert('test');
        });
    });
		
		// add a new block
		document.getElementById("select-block").addEventListener("click", function (e) {
			const span = e.target.closest("span");
			
			if (!span) {
				return;
			}
			
			const selectedPart = span.getAttribute("value");
			
			if (!selectedPart) {
				console.error("selected part is not valid");
				return;
			}
			
			part = 'parts/' + selectedPart;
			partName = selectedPart;
			console.log("selected piece:", selectedPart);
			addBlock();
		});
		
		// list for items that are already in the scene
		document.querySelector("#block-list").addEventListener("click", function (e) {
			if (e.target.matches(".scene-block-item")) {
				const id = e.target.getAttribute("data-id");
				const obj = scene.getObjectByProperty('uuid', id);
				if (obj) {
					transformControls.detach(selectedObject);
					selectedObject = null;
					transformControls.attach(obj);
					selectedObject = obj;
					tooltip('Part selected');
				}
			}
		});
		
		// save creation
		document.getElementById("download-json").addEventListener("click", function () {
			const sceneJSON = generateSceneJSON();
			if (sceneJSON) {
        autosave();

        if (selectedObject) {
          transformControls.detach(selectedObject);
          selectedObject = null;
        }

				const name = document.querySelector("#save-popup input[name='name']").value.trim();
				const desc = document.querySelector("#save-popup textarea[name='desc']").value.trim();
				const screenshot = capture();
				
				this.innerHTML = `<i class="fa fa-spinner fa-spin" aria-hidden="true"></i>`;

				fetch(start_url + "/ajax/build.php", {
					method: "POST",
					headers: { "Content-Type": "application/x-www-form-urlencoded" },
					body: new URLSearchParams({
						save_build: true,
						creation: sceneJSON,
						name,
						desc,
						screenshot
					})
				})
				.then(res => res.json())
				.then(response => {
					tooltip(response.success);
					this.innerText = "Save Creation";
					//this.disabled = true;
				})
				.catch(async err => {
					try {
						const res = await err.response.json();
						tooltip(res.error);
						this.innerText = "Try again";
					} catch {
						tooltip("An unknown error occurred.");
						this.innerText = "Try again";
					}
				});
			} else {
				tooltip('Problem while generating scene');
			}
		});
		
		// import modal
		document.getElementById("import-finish").addEventListener("click", function () {
			const format = document.getElementById("import-format").value;
			if(format === "cloud") {
				tooltip('GR8BRIK models from your account cannot be imported yet.');
				return;
			}
			if(format === "three") {
				document.getElementById("cre-import-three").click();
			}
			if(format === "json") {
				document.getElementById("cre-import").click();
			}
			if(format === "lxf") {
				document.getElementById("cre-export-ldd").click();
			}
      if(format === "ldr") {
        document.getElementById("cre-import-ldr").click();
      }
		});
		
		// export model
		document.getElementById("export-finish").addEventListener("click", function () {
			const format = document.getElementById("export-format").value;
      selectedExport = document.getElementById("export-format").value;

			if(format === "three") {
				document.getElementById("cre-export-three").click();
			}

			if(format === "json") {
				document.getElementById("cre-export").click();
			}

      if(format === "gr8") {
				document.getElementById("cre-export-gr8").click();
			}

			if(format === "lxf") {
				document.getElementById("cre-export-ldd").click();
			}

			if(format === "dae") {
				const collada = new THREE.ColladaExporter();
				const collada_data = collada.parse(filter_objects_peices());
				const blob = new Blob([collada_data.data], { type: 'model/vnd.collada+xml' });
				const url = URL.createObjectURL(blob);
				const date = getDate();

				const a = document.createElement('a');
				a.href = url;
				a.download = `collada-${date}.dae`;
				a.click();

				setTimeout(() => {
					URL.revokeObjectURL(url);
				}, 10000);
			}

      // gltfexporter is async
      if (format === "glb") {
        const exporter = new THREE.GLTFExporter();
        const date = getDate();
        const scene = filter_objects_peices();
        console.log(scene.children.length, "meshes to export");

        exporter.parse(
          scene,
          function (result) {
            //const blob = new Blob([JSON.stringify(result, null, 2)], { type: 'application/json' });
            const blob = new Blob([result], { type: 'model/gltf-binary' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = `creation-${date}.glb`;
            a.click();

            setTimeout(() => 
              URL.revokeObjectURL(url), 
            10000);
          },
          {
            binary: true,
            onlyVisible: true,
            embedImages: true,
            forceIndices: true,
            forcePowerOfTwoTextures: true,
          }
        );
      }

      if (format === "obj") {
        const exporter = new THREE.OBJExporter();
        const date = getDate();
        const result = exporter.parse(filter_objects_peices());

        const blob = new Blob([result], { type: 'text/plain' });
        const url = URL.createObjectURL(blob);
        const a = document.createElement('a');
        a.href = url;
        a.download = `obj-mtl-${date}.obj`;
        a.click();

        setTimeout(() => URL.revokeObjectURL(url), 10000);
      }

      if (format === "mpd") {
        exportSceneToMPD("creation");
      }
		});

		document.getElementById("part-type-filter").addEventListener("change", function () {
			loadParts(this.value);
		});
		
		// save to cloud menu open and close

		document.getElementById("save-popup-open").addEventListener("click", function () {
			document.getElementById("save-popup").style.display = "block";
		});

		document.querySelector("#save-popup .btn-alt").addEventListener("click", function () {
			document.getElementById("save-popup").style.display = "none";
		});
		
		// import popup open and close
		document.getElementById("import-popup-open").addEventListener("click", function () {
			document.getElementById("import-popup").style.display = "block";
		});

		document.querySelector("#import-popup .btn-alt").addEventListener("click", function () {
			document.getElementById("import-popup").style.display = "none";
		});
		
		// export popup open and close
		document.getElementById("export-popup-open").addEventListener("click", function () {
			document.getElementById("export-popup").style.display = "block";
		});

		document.querySelector("#export-popup .btn-alt").addEventListener("click", function () {
			document.getElementById("export-popup").style.display = "none";
		});

    // settings popup open and close
		document.getElementById("settings-popup-open").addEventListener("click", function () {
			document.getElementById("settings-popup").style.display = "block";
		});

		document.querySelector("#settings-popup .btn-alt").addEventListener("click", function () {
			document.getElementById("settings-popup").style.display = "none";
		});

	});


    $(document).ready(function () {
      $("#color-picker").spectrum({
        color: partColor,
        preferredFormat: "hex",
        showInput: true,
        showPalette: true,
        maxSelectionSize: 4,
        palette: [
          [
            "#C91A09", // Bright Red
            "#F8CC00", // Bright Yellow
            "#0020A0", // Bright Blue
            "#005700", // Dark Green
            "#FE8A18", // Bright Orange
            "#D941BB", // Bright Violet
          ],
          [
            "#000000", // Black
            "#FFFFFF", // White
            "#747371", // Dark Stone Grey (Dark Bluish Grey)
            "#A3A2A4", // Medium Stone Grey (Light Bluish Grey)
            "#958A73", // Dark Tan (Brick Yellow)
            "#6C5C4D", // Brown
          ],
          [
            "#812A00", // Dark Brown
            "#5883C1", // Medium Blue
            "#4B974B", // Sand Green
            "#A52A2A", // Dark Red
            "#B36D2C", // Dark Orange
            "#FCB7BC", // Bright Pink
          ],
          [
            "#60C0E0", // Bright Light Blue
            "#FBE696", // Earth Yellow (Light Yellow)
            "#84B68D", // Bright Green
            "#92B28B", // Lime Green
            "#002A5A", // Dark Blue
            "#DDDD22", // Vibrant Yellow
          ],
        ],
        change: function (color) {
          console.log(`Changed selected color to ${color.toName() || color.toHexString()}`);
          partColor = color.toHexString();
          if (color && selectedObject) {
            changeBlockColor(color.toHexString());
          }
        },
      });

      /*$("#search-parts").on("keyup", function () {
			if(event.which == 13) {
			  let value = $(this).val().toLowerCase().replace(/\s+/g, " ").trim();
			  let list = $("#select-block span");

			  list.sort(function (a, b) {
				  let textA = $(a).text().toLowerCase().replace(/\s+/g, " ").trim();
				  let textB = $(b).text().toLowerCase().replace(/\s+/g, " ").trim();

				  let matchA = textA.indexOf(value) > -1 ? 0 : 1;
				  let matchB = textB.indexOf(value) > -1 ? 0 : 1;

				  return matchA - matchB;
			  });

			  $("#select-block").html(list);
			  list.each(function () {
				  let text = $(this).text().toLowerCase().replace(/\s+/g, " ").trim();
				  //$(this).toggle(text.indexOf(value) > -1);
				  if (text.indexOf(value) > -1) {
					$(this).css('display', 'flex');
				} else {
					$(this).css('display', 'none');
				}
			  });
			}
      });*/

      /*$(document).on("click", ".scene-block-item", function () {
        let id = $(this).data("id");
		  
		if(scene.getObjectByProperty('uuid', id)) {
			part = scene.getObjectByProperty('uuid', id);
			
			transformControls.detach(selectedObject);
			selectedObject = null;
			
			transformControls.attach(part);
            selectedObject = part;
            tooltip('Part selected');
		}
		});  */
    });
  </script>
  <script>
	const three_version = '0.176.0';
    const studSize = 1000;
    let partList = document.getElementById('blk');
    let colList = document.getElementById('select-color');

    document.getElementById("username-field").addEventListener("click", function () {
      var content = document.getElementById("username-content");
      if (content.style.display === "block" || content.style.display === "") {
        content.style.display = "none";
      } else {
        content.style.display = "block";
      }
    });

    document.getElementById("color-picker").addEventListener("click", function () {
      console.log("color picker clicked");
    });

    document.getElementById("duplicate-part").addEventListener("click", function () {
      if(selectedObject) {
        duplicatePart();
      }
    });

    document.getElementById("selected-map").addEventListener("input", function () {
      console.log(`Selected material number is ${this.value}`);
      selectedMap = this.value;
    });
	
	document.getElementById("delete-block").addEventListener("click", function () {
		deleteBlock(selectedObject);
	});

    document.getElementById("takeScreenshot").addEventListener("click", function () {
      let url = capture();
      let date = getDate();
      let a = document.createElement("a");

      a.href = url;
      a.download = `creation-screenshot-${date}.PNG`;
      a.click();
    });

    document.getElementById("toggleMenu").addEventListener("click", function () {
      var left = document.getElementById("left-container");
      if (left.style.left === "0px" || left.style.left === "") {
        left.style.left = "-999px";
      } else {
        left.style.left = "0px";
      }
    });

    document.querySelectorAll('.tab-button').forEach(button => {
      button.addEventListener('click', function () {
        const is1 = this.id === 'tab1';
        var search = document.getElementById("search-parts");
        document.getElementById('select-block').style.display = is1 ? 'flex' :
          'none';
        document.getElementById('block-list').style.display = is1 ? 'none' :
          'block';
        search.readOnly = is1 ? false : true;
      });
    });
	
	document.getElementById("cre-export").addEventListener("click", () => {
        const jsonData = generateSceneJSON();
		const jsonBlob = new Blob([jsonData], { type: "application/json" });
		const elm = this;
		
		const url = URL.createObjectURL(jsonBlob);
		const date = getDate();
		const a = document.createElement("a");
		a.href = url;
		a.download = `json-creation-${date}.json`;
		a.click();
			
		setTimeout(() => {
			URL.revokeObjectURL(url);
		}, 10000);
  });

  document.getElementById("cre-export-gr8").addEventListener("click", () => {
    const fileData = generateSceneJSON();
		const dataBlob = new Blob([fileData], { type: "application/json" });
		const elm = this;
		
		const url = URL.createObjectURL(dataBlob);
		const date = getDate();
		const a = document.createElement("a");
		a.href = url;
		a.download = `gr8brik-creation-${date}.gr8`;
		a.click();
			
		setTimeout(() => {
			URL.revokeObjectURL(url);
		}, 10000);
  });
	
	document.getElementById("cre-export-ldd").addEventListener("click", () => {
		console.log('clicked');
        const legoData = generateSceneLXFML();
		const zip = new JSZip();
		zip.file("IMAGE100.LXFML", legoData);
		const elm = this;
		
		zip.generateAsync({ type: "blob" }).then(function (blob) {
			const url = URL.createObjectURL(blob);
			const date = getDate();
			
			const a = document.createElement("a");
			a.href = url;
			a.download = `ldd-creation-${date}.lxf`;
			a.click();
			
			URL.revokeObjectURL(url);
		});
    });
	
	document.getElementById("cre-export-three").addEventListener("click", () => {
		if (!scene) {
			tooltip("Scene is empty");
			return;
		}

		const date = getDate();
		const json = scene.toJSON();
		const jsonString = JSON.stringify(json);
		const blob = new Blob([jsonString], { type: "application/json" });
		const url = URL.createObjectURL(blob);

		const a = document.createElement("a");
		a.href = url;
		a.download = `threejs-${date}.json`;
		a.click();
		URL.revokeObjectURL(url);
	});

  function exportSceneToMPD(name) {
    const lines = [];

    const ldraw_color_map = {
      "C91A09": 4, // Bright Red
      "F8CC00": 14, // Bright Yellow
      "0020A0": 12, // Bright Blue
      "005700": 28, // Dark Green
      "FE8A18": 10, // Bright Orange
      "D941BB": 124, // Bright Violet / Dark Purple

      "000000": 0, // Black
      "FFFFFF": 15, // White
      "747371": 294, // Dark Stone Grey / Dark Bluish Grey
      "A3A2A4": 295, // Medium Stone Grey / Light Bluish Grey
      "958A73": 5, // Brick Yellow / Tan
      "6C5C4D": 8, // Dark Stone Grey / Dark Brown

      "812A00": 308, // Reddish Brown
      "5883C1": 23, // Medium Blue
      "4B974B": 37, // Sand Green
      "A52A2A": 59, // Dark Red
      "B36D2C": 38, // Dark Orange
      "FCB7BC": 223, // Bright Pink

      "60C0E0": 212, // Bright Light Blue
      "FBE696": 226, // Light Yellow
      "84B68D": 36, // Bright Green
      "92B28B": 335, // Bright Yellowish Green / Lime
      "002A5A": 26, // Dark Blue
      "DDDD22": 334, // Vibrant Yellow
    };

    lines.push(`0 FILE ${name}.ldr`);
    lines.push(`0 ${name}`);
    lines.push(`0 Name: ${name}.ldr`);
    lines.push(`0 Author: Exported from Three.js`);
    lines.push(`0 !LDRAW_ORG Model`);
    lines.push(`0 !LICENSE Redistributable under CCAL version 2.0`);
    lines.push(`0`);

    scene.traverse(child => {
      if (!child.isMesh || !child.userData.ldraw || !child.userData.isBlock) {
        return;
      }

      const obj = child.clone();
      obj.applyMatrix4(new THREE.Matrix4().makeScale(1, 1, -1));
      obj.updateMatrixWorld(true);

      let color_code = 16;
      if(obj.material && !Array.isArray(obj.material)) {
        const hex = obj.material.color.getHexString() || "ffffff";
        color_code = ldraw_color_map[hex.toUpperCase()];
      }

      const file = obj.userData.ldraw.replace("parts/", "");
      const color = color_code;

      const pos = new THREE.Vector3();
      const quat = new THREE.Quaternion();
      const scale = new THREE.Vector3();
      obj.matrixWorld.decompose(pos, quat, scale);

      /* const matrix = new THREE.Matrix3().setFromMatrix4(obj.matrixWorld);

      const e = matrix.elements;

      const rot = e;
      const x = pos.x;
      const y = pos.y;
      const z = pos.z; */

      const scaleFactor = 1000 / 0.4;

      //const matrix = new THREE.Matrix3().setFromMatrix4(obj.matrixWorld);
      //const rot = matrix.elements.map(n => n.toFixed(5));
      //const e = matrix.elements;

      const e = obj.matrixWorld.elements;

      const rot = [
        e[0], e[4], e[8],  e[12] * scaleFactor,
        e[1], e[5], e[9],  e[13] * scaleFactor,
        e[2], e[6], e[10], e[14] * scaleFactor,
      ].map(n => n.toFixed(5));

      /* const x = (pos.x * scaleFactor).toFixed(2);
      const y = (pos.y * scaleFactor).toFixed(2);
      const z = (pos.z * scaleFactor).toFixed(2); */

      //const line = `1 ${color} ${x} ${y} ${z} ${rot.join(' ')} ${file}`;
      const line = `1 ${color} ${rot.join(' ')} ${file}`;
      lines.push(line);
    });

    let result =  lines.join('\n');
    const date = getDate();

    const blob = new Blob([result], { type: 'text/plain' });
    const url = URL.createObjectURL(blob);
    const a = document.createElement('a');
    a.href = url;
    a.download = `creation-${date}.mpd`;
    a.click();

    setTimeout(() => URL.revokeObjectURL(url), 10000);
  }


    document.getElementById("cre-import").addEventListener("change", function (event) {
        let file = event.target.files[0];
        if (!file) {
            console.error("No file selected");
            tooltip("No file selected.");
            return;
        }

        const reader = new FileReader();
        reader.onload = function (e) {
            try {
                const jsonData = JSON.parse(e.target.result);
                loadSceneFromJSON(jsonData);
            } catch (err) {
                tooltip("Invalid JSON file.");
                console.error(err);
            }
            event.target.value = "";
        };
        reader.readAsText(file);
    });

    document.getElementById("cre-import-ldr").addEventListener("change", function (event) {
      let file = event.target.files[0];
      if (!file) {
        console.error("No file selected");
        tooltip("No file selected.");
        return;
      }

      const reader = new FileReader();
      reader.onload = function (e) {
        try {
          const content = e.target.result;

          ldraw_loader.parse(content, function (creation) {
            const converted = ldrawToJSON(creation);
            console.log("converted: " + JSON.stringify(converted, null, 2));
            loadSceneFromJSON(converted);
          });
        } catch (err) {
          tooltip("Invalid LDraw file.");
          console.error(err);
        }

        event.target.value = "";
      };

      reader.readAsText(file);
    });
  
	async function loadSceneFromJSON(data) {
		if (!data || !data.blocks || !Array.isArray(data.blocks)) {
			console.error("Invalid JSON data.");
			tooltip("Invalid JSON.");
			return;
		}

		for (const block of data.blocks) {
			partName = block.ldraw;
			partColor = '#' + block.color;
			partPosition = block.position;
			partRotation = block.rotation;

			part = 'parts/' + block.ldraw;

			try {
				await new Promise((resolve, reject) => {
					addBlock(resolve, reject);
				});
			} catch (err) {
				console.warn(`Failed to add block: ${block.ldraw}`, err);
				tooltip(`Failed to load ${block.ldraw}`);
			}
		}

		console.log("Creation imported.");
		tooltip("Creation imported.");
	}

  function ldrawToJSON(group) {
    const blocks = [];

    group.traverse(function (child) {
      if (child.isGroup && child.parent && child.parent.userData && child.parent.userData.fileName) {
        const ldraw_data = child.parent.userData;

        const fileName = ldraw_data.fileName || "3001.dat";
        const partName = fileName.substring(fileName.lastIndexOf("/") + 1);
        const colorCode = ldraw_data.colorCode?.toString(16).padStart(6, "0") || "ffffff";

        const worldPos = new THREE.Vector3();
        child.parent.getWorldPosition(worldPos);

        const worldQuat = new THREE.Quaternion();
        child.parent.getWorldQuaternion(worldQuat);

        const euler = new THREE.Euler().setFromQuaternion(worldQuat);
        child.parent.scale.set(1, 1, 1);

        blocks.push({
          color: colorCode,
          position: { x: worldPos.x, y: worldPos.y, z: worldPos.z },
          rotation: { x: euler.x, y: euler.y, z: euler.z },
          ldraw: partName
        });
      }
    });

    return { blocks };
  }
	
	/*document.getElementById("import-btn-three").addEventListener("click", function () {
		document.getElementById("cre-import-three").click();
    }); */
	
	document.getElementById("cre-import-three").addEventListener("change", function (event) {
        let file = event.target.files[0];
        if (!file) {
            console.error("No file selected");
            tooltip("No file selected");
            return;
        }

        const reader = new FileReader();
		
        reader.onload = function (e) {
          try {				
            const data = JSON.parse(e.target.result);
            const loader = new THREE.ObjectLoader();

            let object;

            if (data.metadata && data.metadata.type && data.metadata.type === "App" && data.object) {
                object = loader.parse(data.object);
            } else {
                object = loader.parse(data);
            }
            
            object.children.forEach(function(child) {
              child.userData.noSnap = true;
              child.userData.isBlock = true;
              child.userData.partName = object.ldraw;
              child.ldraw = object.ldraw;
              scene.add(child);
            });
            
            if(selectedObject) {
              transformControls.detach(selectedObject);
              selectedObject = null;
            }
          } catch (err) {
            tooltip(`error: ${err}`);
            console.error(err);
          }
          event.target.value = "";
          updateSceneData();
        };
        reader.readAsText(file);
    });

    var container, camera, scene, renderer, controls, grid_helper, directional_lighting, ambient_lighting, ldraw_loader, loading_manager, mouse, partRotation, partPosition, selectedObject, customPosition, selectedMap, selectedExport, named_parts = null;

    let blocks = [];
    let blockGroups = [];

    init();
    animate();

    function getCookie(name) {
        var cookies = document.cookie;
        var parts = cookies.split(name + "=");
        var cookieValue = null;
        if (parts.length == 2) {
            cookieValue = parts.pop().split(";").shift();
        }
        return cookieValue;
    }

    function toggleGlobalSnap() {
      if(scene.userData.noSnap === true) {
        scene.userData.noSnap = false;
      } else {
        scene.userData.noSnap = true;
      }
      scene.updateMatrixWorld(true);
    }

    // toggle smooth normals
    // todo make this actually work
    document.getElementById("smooth-normals-enable").addEventListener("change", function () {
      ldraw_loader.smoothNormals = this.checked;

      scene.traverse((child) => {
        if (child.isMesh && child.userData.isBlock && child.geometry) {
          if (Array.isArray(child.material)) {
            child.material.forEach(mat => {
              mat.flatShading = !ldraw_loader.smoothNormals;
              mat.needsUpdate = true;
            });
          } else {
            child.material.flatShading = !ldraw_loader.smoothNormals;
            child.material.needsUpdate = true;
          }
        }
      });
      scene.updateMatrixWorld(true);
    });

    document.getElementById("display-lines-enable").addEventListener("change", function () {
      const displayLines = this.checked;
      scene.userData.displayLines = displayLines;

      scene.traverse((obj) => {
        if (obj.isLineSegments && obj.userData && obj.userData.ldr_line === true) {
          obj.visible = displayLines;
        }
      });

      scene.updateMatrixWorld(true);
    });

    function isDark() {
        if(getCookie('mode')) {
          if(getCookie('mode') === 'dark') {
            return true;
          } else {
            return false;
          }
        } else {
          if(window.matchMedia("(prefers-color-scheme: dark)").matches) {
            return true;
          } else {
            return false;
          }
        }
    }

  function snapToGrid(value, gridSize) {
    return Math.round(value / gridSize) * gridSize;
  }
	
	function getDate() {
		const today = new Date();
		const yyyy = today.getFullYear();
		const mm = String(today.getMonth() + 1).padStart(2, '0');
		const dd = String(today.getDate()).padStart(2, '0');

		return `${yyyy}-${mm}-${dd}`;
	}

  function init() {
    if(isDark()) {
			document.body.classList.add("dark");
		} else {
      if(document.body.classList.contains("dark")) {
			  document.body.classList.remove("dark");
      }
		}

    // Scene container
    container = document.createElement('div');
    container.classList.add("scene");
    document.body.appendChild(container);

    // Scene
    scene = new THREE.Scene();
    scene.userData.noSnap = false;
    scene.userData.displayLines = false;

    if(isDark()) {
			scene.background = new THREE.Color(0x252424);
		} else {
			scene.background = new THREE.Color(0xfafafa);
		}

    // WebGl renderer
    renderer = new THREE.WebGLRenderer({alpha: true});
    renderer.setSize(window.innerWidth, window.innerHeight);

    // set pixel ratio
    // @the_an0nym pointed out how if your screen resolution isn't 100% (and in some cases just always), the scene looks buggy
    renderer.setPixelRatio(window.devicePixelRatio);
    container.appendChild(renderer.domElement);
		
    // Camera
    camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 10000);
    camera.position.set(250, 250, 250);
		
    // Lighting
		ambient_lighting = new THREE.AmbientLight(0xdddddd, 1);
    scene.add(ambient_lighting);

		directional_lighting = new THREE.DirectionalLight(0xffffff, 3);
    directional_lighting.position.set(250, 250, 250);
    scene.add(directional_lighting);

    const rgbe_loader = new THREE.RGBELoader();
    //https://polyhaven.com/a/autumn_field_puresky
    rgbe_loader.load('https://cdn.jsdelivr.net/gh/susstevedev/gr8brik/lib/autumn_field_puresky_1k.hdr', function (texture) {
      texture.mapping = THREE.EquirectangularReflectionMapping;
      scene.environment = texture;
    });

    transformControls = new THREE.TransformControls(camera, renderer.domElement);
    scene.add(transformControls);

    controls = new THREE.OrbitControls(camera, renderer.domElement);
    controls.enableDamping = true;
    controls.dampingFactor = 0.8;

    const stud_size = 20; // 1 stud = 20 three/ldr units
    const grid_size = stud_size * 16; // studs wide
    const divisions = 16; // 1 division per stud
		
		if(isDark()) {
			grid_helper = new THREE.GridHelper(grid_size, divisions, 0x242424, 0xfafafa);
			scene.add(grid_helper);
		} else {
			grid_helper = new THREE.GridHelper(grid_size, divisions, 0xfafafa, 0x242424);
			scene.add(grid_helper);
		}

    loading_manager = new THREE.LoadingManager();

    loading_manager.setURLModifier((url) => {
      return url;
    });

    loading_manager.onError = (url) => {
      console.warn("missing part " + url);
      loading_manager.itemEnd(url);
    };
	
	named_parts = new Map();

    const ldraw_path = "https://raw.githubusercontent.com/susstevedev/gr8brik-ldraw-fork/refs/heads/main/ldraw-parts/";
    ldraw_loader = new THREE.LDrawLoader();
    ldraw_loader.preloadMaterials(ldraw_path + 'colors/ldconfig.ldr');
    ldraw_loader.setPath(ldraw_path + 'actual/');
    ldraw_loader.setPartsLibraryPath(ldraw_path + 'actual/');
	
	  // lifesaver thanks chatgpt
	  ldraw_loader.separateObjects = true;
        
    raycaster = new THREE.Raycaster();
    mouse = new THREE.Vector2();

    window.addEventListener('keydown', function (event) {
      let activeElement = document.activeElement;

      if (activeElement.tagName === "INPUT" || activeElement.tagName === "TEXTAREA") {
        return;
      }

      switch (event.code) {
        case 'KeyT':
          moveBlock('t')
          break
        case 'KeyR':
          moveBlock('r')
          break
        case 'KeyS':
          moveBlock('s')
          break
        case 'Escape':
          deselect(selectedObject);
          break
        case 'Delete':
          deleteBlock(selectedObject);
          break
        case 'ArrowUp':
          selectedObject.rotation.x -= THREE.MathUtils.degToRad(45);
          break;
        case 'ArrowDown':
          selectedObject.rotation.x += THREE.MathUtils.degToRad(45);
          break;
        case 'ArrowLeft':
          selectedObject.rotation.y -= THREE.MathUtils.degToRad(45);
          break;
        case 'ArrowRight':
          selectedObject.rotation.y += THREE.MathUtils.degToRad(45);
          break;
        }
      })

      document.getElementById('move-block-t').addEventListener('click', function () {
        if (selectedObject) {
          moveBlock('t');
        }
      });

      document.getElementById('move-block-r').addEventListener('click', function () {
        if (selectedObject) {
          moveBlock('r');
        }
      });

      window.addEventListener('resize', onWindowResize, true);
      window.addEventListener('pointerdown', onMouseClick, true);

      transformControls.addEventListener('mouseDown', function () {
        controls.enabled = false;
      });

      transformControls.addEventListener('mouseUp', function () {
        controls.enabled = true;
      });

      transformControls.addEventListener('dragging-changed', function (event) {
        controls.enabled = !event.value;
      });

      /* transformControls.addEventListener('objectChange', function () {
        if (selectedObject && !(selectedObject.userData.noSnap || scene.userData.noSnap)) {
          selectedObject.position.set(
            snapToGrid(selectedObject.position.x, 10), 
            snapToGrid(selectedObject.position.y, 4), 
            snapToGrid(selectedObject.position.z, 10)
          );

          selectedObject.rotation.set(
            Math.round(selectedObject.rotation.x / THREE.MathUtils.degToRad(45)) * THREE.MathUtils.degToRad(45),
            Math.round(selectedObject.rotation.y / THREE.MathUtils.degToRad(45)) * THREE.MathUtils.degToRad(45),
            Math.round(selectedObject.rotation.z / THREE.MathUtils.degToRad(45)) * THREE.MathUtils.degToRad(45)
          );

          selectedObject.updateMatrixWorld(true);
          scene.updateMatrixWorld(true);
        }
        updateSceneData();
      });		*/

      let original_pos = new THREE.Vector3();
      let original_rot = new THREE.Euler();

      transformControls.addEventListener('mouseDown', () => {
        if (selectedObject) {
          original_pos.copy(selectedObject.position);
          original_rot.copy(selectedObject.rotation);
        }
      });

      transformControls.addEventListener('objectChange', function () {
        if (selectedObject && !(selectedObject.userData.noSnap || scene.userData.noSnap)) {
          const delta_pos = new THREE.Vector3().subVectors(selectedObject.position, original_pos);
          const snapped_pos = new THREE.Vector3(
            snapToGrid(delta_pos.x, 10),
            snapToGrid(delta_pos.y, 4),
            snapToGrid(delta_pos.z, 10)
          );

          const final_pos = original_pos.clone().add(snapped_pos);
          selectedObject.position.copy(final_pos);

          const delta_rot = new THREE.Euler(
            selectedObject.rotation.x - original_rot.x,
            selectedObject.rotation.y - original_rot.y,
            selectedObject.rotation.z - original_rot.z
          );

          const snapped_rot = new THREE.Euler(
            Math.round(delta_rot.x / THREE.MathUtils.degToRad(45)) * THREE.MathUtils.degToRad(45),
            Math.round(delta_rot.y / THREE.MathUtils.degToRad(45)) * THREE.MathUtils.degToRad(45),
            Math.round(delta_rot.z / THREE.MathUtils.degToRad(45)) * THREE.MathUtils.degToRad(45)
          );

          const final_rot = new THREE.Euler(original_rot.x + snapped_rot.x, original_rot.y + snapped_rot.y, original_rot.z + snapped_rot.z);

          selectedObject.rotation.copy(final_rot);

          selectedObject.updateMatrixWorld(true);
          scene.updateMatrixWorld(true);
        }
        updateSceneData();
      });

    }

    /*function changeBlockColor(color) {
      if (!selectedObject) {
        tooltip("No part selected");
        return;
      }

      selectedObject.traverse((child) => {
		//if (child.isMesh && child.material && !Array.isArray(child.material)) {
			child.material.color.set(color);
			child.material.needsUpdate = true;
		//}
      });

      console.log(`part color changed to ${color}`);
      tooltip(`Part color changed`);
    } */
	
	function changeBlockColor(color) {
		if (!selectedObject) {
			tooltip("No part selected");
			return;
		}

		selectedObject.traverse((child) => {
			if (child.isMesh && child.material) {
				if (Array.isArray(child.material)) {
          let mat;
          if (selectedMap != null) {
            if (child.material[selectedMap]) {
              mat = child.material[selectedMap];
            } else {
              selectedMap = null;
              tooltip('Invalid multi color map selected');
              return;
            }
          } else {
            mat = child.material[0];
          }

          if (mat && mat.color && !mat.map) {
            mat.color.set(color);
            mat.needsUpdate = true;
          }

          selectedMap = null;
          updateSceneData();
		  updateBLItems();
        } else if (child.material.color) {
			child.material.color.set(color);
			child.material.needsUpdate = true;
			updateSceneData();
			updateBLItems();
          
				}
			}
		});

		console.log(`Part color changed to ${color}`);
		tooltip(`Part color changed to ${color}`);
	}

  function deleteBlock(part) {
    if (part) {
      if (part.isMesh || part.isGroup) {
        if (part.parent) {
          transformControls.detach(selectedObject);
          selectedObject = null;
		  part.parent.remove(part);
        }
        part.updateMatrixWorld(true);
        tooltip('Deleted part');
      } else {
        tooltip('Part is not a valid mesh')
      }

      /*if (blockGroups && blockGroups.length > 0) {
        blockGroups.forEach(function (g) {
		  if(g.uuid === part.parent.uuid) {
			  if(g.part) {
				g.remove(part);
			  }
			  g.updateMatrixWorld(true);
			  updateBLItem(g.userData.partName, color, g.userData.sceneCount, g.uuid);
		  }
        });
      } */
	  
	  updateBLItems();

      if (selectedObject === part) {
          deselect(part);
      }
  } else {
      tooltip('No part found');
  }
		scene.updateMatrixWorld(true);
		updateSceneData();
  }

  function capture() {
    let thumb = new THREE.Scene();
    thumb.background = null;

    let count = 0;

    scene.traverse(function (object) {
      if (object.isMesh) {
        let cloned = clone_mesh_clean(object);
        if (cloned) {
          thumb.add(cloned);
          if(object.userData.isBlock) {
            cloned.rotation.setFromQuaternion(cloned.quaternion);
            /* cloned.rotation.z += Math.PI;
            cloned.rotation.y += Math.PI; */
          }
          console.log(cloned);
          count++;
        }
      }
    });

    if (count === 0) {
      console.warn("scene is empty");
      return null;
    }

    let light2 = new THREE.DirectionalLight(0xffffff, 1);
    light2.position.set(250, 250, 250);
    thumb.add(light2);

    let camera2 = camera.clone();

    let ambient2 = new THREE.AmbientLight(0xdddddd);
    thumb.add(ambient2);

    let renderer = new THREE.WebGLRenderer({ antialias: true, preserveDrawingBuffer: true });
    renderer.setClearColor(0x000000, 0); // transparent
    renderer.setSize(500, 500);
    renderer.render(thumb, camera2);

    let thumbnail = renderer.domElement.toDataURL("image/png");
    return thumbnail;
  }

  function makeid(length) {
      let result = '';
      const characters = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789';
      let counter = 0;

      while (counter < length) {
        result += characters.charAt(Math.floor(Math.random() * characters.length));
        counter += 1;
      }

      return result;
  }

    // Last cleaned up 6/2/2025 by susstevedev
  function addBlock(throwSuccess, throwError) {
        if (!ldraw_loader) {
            console.error('LdrawLoader is missing or not loaded yet.');
            tooltip('Something really, really, wrong has occured. Weird...');
            return;
        }

        if (!part) {
            console.error('No part is selected!');
            tooltip('Please select a part.');
            return;
        }

        if (!partColor) {
            console.warn('Part color is not set. Setting color as white.');
            partColor = "#ffffff";
        }

        transformControls.detach(selectedObject);
        console.log("Loading part:", part);

        ldraw_loader.load(part, function (loadedGroup) {
            if (!loadedGroup) {
                console.error("Loaded group does not exist.");
                tooltip('Please select a block with valid mesh data');
                return;
            }

            let blockGroup = new THREE.Group();
            blockGroup.name = `ldraw_${makeid(10)}`;
            blockGroup.ldraw = part;

            let display_lines = scene.userData.displayLines;
			
            loadedGroup.traverse((child) => {
              if (child.isLineSegments && child.parent.isGroup) {
                child.visible = false;
                return;
              }

              if (child.isMesh && !child.material.map && !child.isLineSegments && !Array.isArray(child.material)) {
                  const pos = new THREE.Vector3();
                  const pos2 = child.getWorldPosition(pos);
                  console.log(pos2);

                  child.material = new THREE.MeshPhysicalMaterial({
                    color: new THREE.Color(partColor || "#000000"),
                    reflectivity: 0.5,
                    roughness: 0.4,
                    metalness: 0.1,
                    envMapIntensity: 0.5,
                  });

                  child.userData.isBlock = true;
                  child.userData.isTexture = false;
                  child.userData.ldraw = child.parent.userData.fileName || partName;
                  child.userData.ldr_line = false;
                  
                  transformControls.attach(child);
                  selectedObject = child;
              }

              if (child.material && child.material.map && child.isMesh && !child.isLineSegments) {
                child.userData.isBlock = true;
                child.userData.isTexture = true;
                child.userData.ldraw = child.parent.userData.fileName || partName;
				        child.userData.ldr_line = false;
              }

				      child.userData.parentName = partName;
              child.userData.id = makeid(15);
              child.userData.original_mat = child.material;

              if (child.material && child.isMesh && !child.isLineSegments) {
                const edges = new THREE.EdgesGeometry(child.geometry); 
                const line = new THREE.LineSegments(edges, new THREE.LineBasicMaterial( { color: 0x000000 } ) );
                line.userData.ldr_line = true;
                child.add(line);

                if(display_lines != true) {
                  line.visible = false;
                }
              }
            });

            blockGroup.add(loadedGroup);
              
            if(partPosition && partRotation) {
              blockGroup.position.set(partPosition.x, partPosition.y, partPosition.z);
              blockGroup.rotation.set(partRotation.x, partRotation.y, partRotation.z);
            } else {
              blockGroup.position.y = objectSize(blockGroup).y;
              blockGroup.rotation.x = Math.PI;
            }
              
            blockGroup.userData.partName = partName;
            scene.add(blockGroup);
              
            blocks.push(blockGroup);
            blockGroups.push(blockGroup);
            blockGroup.sceneCount = blocks.length;

            tooltip(`Added part ${part.replace("parts/", "")}`);

            /* const texturename = `${part.split("/").pop().split(".")[0]}.png`;
            const texturepath = `https://raw.githubusercontent.com/susstevedev/gr8brik-ldraw-fork/refs/heads/main/ldraw-parts/actual/parts/textures/${texturename}`;
            const texturepath = 'https://d1xez26aurxsp6.cloudfront.net/users/qXBby2/avatars/680a924dab4ba.png';
            const textureLoader = new THREE.TextureLoader();

            textureLoader.load(texturepath, (texturemap) => {
                texturemap.colorSpace = THREE.SRGBColorSpace;
                blockGroup.traverse(child => {
                    if (child.isMesh && child.material) {
                        child.material.map = texturemap;
                        child.material.needsUpdate = true;
                    }
                });
            }, undefined, (err) => {
                console.warn("Texture load failed or doesn't exist:", err);
            }); */

            updateBLItems();
            updateSceneData();
            throwSuccess();
      }, undefined, function (error) {
          console.error('error loading piece:', error);
          throwError(error);
      });
  }

  /*function updateBlockList(part, color, count, id) {
    let blockList = document.getElementById('block-list');
    let listItem = document.createElement('li');

    listItem.classList.add('scene-block-item');
    listItem.setAttribute('data-id', id);
    listItem.textContent = `${part} (${color}, Num ${count})`;

    blockList.appendChild(listItem);
  }

  function removeBLItem(id) {
    let item = document.querySelector(`li[data-id="${id}"]`);
    if (item) {
      item.remove();
    }
  } 

  function updateBLItem(part, color, count, id) {
    removeBLItem(id);
    updateBlockList(part, color, count, id);
    console.log('updated block list');
  } */
  
  function getBLItems() {
	  const items = [];
	  scene.traverse(obj => {
		if (obj.isMesh || obj.isGroup) {
			if(obj.userData.isBlock || obj.isGroup) {
				items.push(obj);
			}
		}
	  });
	  return items;
  }
	
	function updateBLItems() {
		const items = getBLItems();
		const blockList = document.getElementById('block-list');
		blockList.innerHTML = "";
		
		items.forEach(obj => {
			const item = renderBLItem(obj, 0);
			blockList.appendChild(item);
		});
	}
	
	function renderBLItem(obj, level = 0) {
		const id = obj.uuid;
		const color = obj.material?.color?.getHexString?.() || "No material";
		
		let part;
		if (obj.userData.isBlock) {
			part = `Part ${obj.parentName || obj.parent.parentName || obj.parent.parent.parentName} (Group ${level})`;
		} else {
			part = obj.name || `Group ${level}`;
		}

		const li = document.createElement('li');
		li.classList.add('scene-block-item');
		li.setAttribute('data-id', id);
		li.textContent = `${part} (${color})`;

		if (obj.children && obj.children.length > 0) {
			const ul = document.createElement('ul');

			obj.children.forEach(child => {
				if (child.isMesh || child.isGroup) {
					const childLi = renderBLItem(child, level + 1);
					ul.appendChild(childLi);
				}
			});

			li.appendChild(ul);
		}

		return li;
	}

  function subobjectPosition(g) {
      g.updateMatrixWorld(true);

      const position = new THREE.Vector3();
      const quaternion = new THREE.Quaternion();
      const scale = new THREE.Vector3();

      g.matrixWorld.decompose(position, quaternion, scale);

      const m = g.clone();

      m.position.copy(position);
      m.quaternion.copy(quaternion);
      m.scale.copy(scale);

      m.updateMatrix();
      return m;
  }
	
	function objectSize(obj) {
		if (!obj) {
			return new THREE.Vector3(0, 0, 0);
		}

		const b = new THREE.Box3().setFromObject(obj);
		const s = new THREE.Vector3();
		b.getSize(s);

		return s;
	}

  function isSmall(g, scale) {
    const boundingBox = new THREE.Box3().setFromObject(g);
    const size = new THREE.Vector3();
    boundingBox.getSize(size);

    return size.x < scale || size.y < scale || size.z < scale;
  }

  function generateUVMap(geometry) {
    geometry.computeBoundingBox();
    geometry.computeVertexNormals();

    const uvs = [];

    const position = geometry.attributes.position;
    const box = geometry.boundingBox;

    for (let i = 0; i < position.count; i++) {
      const x = position.getX(i);
      const y = position.getY(i);
      const u = (x - box.min.x) / (box.max.x - box.min.x);
      const v = (y - box.min.y) / (box.max.y - box.min.y);
      uvs.push(u, v);
    }

    geometry.setAttribute('uv', new THREE.Float32BufferAttribute(uvs, 2));
    return geometry;
  }

  function getPriceInfo() {
    if(selectedObject) {
      let part = selectedObject.parent.userData.fileName.replace("parts/", "").replace(".dat", "");

      fetch(`parts.php?part_price=true&part=${part}`)
        .then(res => res.json())
        .then(data => {
          const price = data.part_prices?.USD?.new;
          if (price !== undefined) {
            console.log("new price in united states dollars: $" + price);
          } else {
            console.warn(`price data unavailable for ${part}`);
          }
        });
		}
  }

  function getFilename(obj) {
    if(obj) {
      while (obj) {
        if (obj.userData) {
          if(obj.userData.fileName) {
            return obj.userData.fileName;
          }
        }
        obj = obj.parent;
      }
      return null;
    }
  }

  function duplicatePart() {
    if(selectedObject) {
      part = `parts/${selectedObject.userData.parentName}`;
      partName = selectedObject.userData.parentName;
      partColor = `#${selectedObject.material.color.getHexString().toLowerCase()}`;
      addBlock();
    }
  }
  
	function createGroup(gname, gelm) {
		let group = new THREE.Group();
    group.name = gname;
		group.add(gelm);
    return group;
	}
  
    /* function generateSceneJSON() {
      let sceneData = {
        metadata: {
          file_version: 1.2,
          name: "My Model",
          description: null
        },
        camera: camera.position,
        blocks: []
      };

      if (selectedObject) {
        transformControls.detach(selectedObject);
        selectedObject = null;
      }

      blockGroups.forEach(function (group) {
        if (!group || !group.userData.partName) {
          return;
        }

        let group_color = null;
        let mesh_child = null;

        let pos = new THREE.Vector3();
        let rot = new THREE.Quaternion();
        let scale = new THREE.Vector3();
        let euler = new THREE.Euler();

        group.traverse(function (child) {
          if (child.isMesh) {
            // saving the child object because using the group itself doesn't work
            // todo update block groups in the updateSceneData() function
            // 6/14/2025
            mesh_child = child;
            
            mesh_child.updateMatrixWorld(true);
            mesh_child.getWorldPosition(pos);
            mesh_child.getWorldQuaternion(rot);
            mesh_child.getWorldScale(scale);
            euler.setFromQuaternion(rot);
			
            if (Array.isArray(child.material)) {
              mesh_color = child.material[0].color.getHexString().toLowerCase();
            } else {
              mesh_color = child.material.color.getHexString().toLowerCase();
            }
          }
        });

        const blockData = {
          partName: group.userData.partName,
          color: mesh_color || 'c91a09',

          // use matrixes because child objects only store local location values and not global ones
          position: {
            x: pos.x,
            y: pos.y,
            z: pos.z
          },
          rotation: {
            x: euler.x,
            y: euler.y,
            z: euler.z
          },
          scale: {
            x: scale.x,
            y: scale.y,
            z: scale.z
          },
          blockID: group.name,
          //ldraw: group.ldraw.replace("parts/", ""),
		  ldraw: mesh_child.userData.ldraw,
        };

        sceneData.blocks.push(blockData);
      });

      return JSON.stringify(sceneData, null, 2);
    } */
	
	function generateSceneJSON() {
	  let sceneData = {
      metadata: {
        file_version: 1.2,
        name: "My Model",
        description: null
      },
      camera: camera.position,
      settings: JSON.stringify(scene.userData),
      blocks: []
	  };

	  /* if (selectedObject) {
      transformControls.detach(selectedObject);
      selectedObject = null;
	  } */

	  blockGroups.forEach(function (group) {
      if (!group) {
        return;
      }

      const meshes = [];

      group.traverse(function (child) {
        if (child.isMesh && child.userData.isBlock) {
          meshes.push(child);
        }
      });

      meshes.forEach(mesh_child => {
        const pos = new THREE.Vector3();
        const rot = new THREE.Quaternion();
        const scale = new THREE.Vector3();
        const euler = new THREE.Euler();

        mesh_child.updateMatrixWorld(true);
        mesh_child.getWorldPosition(pos);
        mesh_child.getWorldQuaternion(rot);
        mesh_child.getWorldScale(scale);
        euler.setFromQuaternion(rot);

        // Colors
        if (Array.isArray(mesh_child.material)) {
          mesh_color = mesh_child.material[0].color.getHexString().toLowerCase();
        } else {
          mesh_color = mesh_child.material.color.getHexString().toLowerCase();
        }

        const blockData = {
          color: mesh_color,
          position: {
            x: pos.x,
            y: pos.y,
            z: pos.z
          },
          rotation: {
            x: euler.x,
            y: euler.y,
            z: euler.z
          },
          scale: {
            x: scale.x,
            y: scale.y,
            z: scale.z
          },
          id: mesh_child.userData.id || mesh_child.uuid,
          ldraw: mesh_child.userData.ldraw.replace("parts/", ""),
        };

        sceneData.blocks.push(blockData);
      });
	  });

	  return JSON.stringify(sceneData);
	}

    function generateSceneLXFML() {
      let sceneBricks = '';
      let boneRefs = [];
      let refID = 0;
      let totalPosition = new THREE.Vector3();
      let count = 0;

      if (selectedObject) {
        transformControls.detach(selectedObject);
        selectedObject = null;
      }

      const lego_color_map = {
        "C91A09": 21, // Bright Red
        "F8CC00": 24, // Bright Yellow
        "0020A0": 23, // Bright Blue
        "005700": 28, // Dark Green
        "FE8A18": 25, // Bright Orange
        "D941BB": 221, // Bright Violet

        "000000": 26, // Black
        "FFFFFF": 1, // White
        "747371": 199, // Dark Bluish Grey
        "A3A2A4": 208, // Light Bluish Grey
        "958A73": 2, // Brick Yellow
        "6C5C4D": 86, // Dark Brown

        "812A00": 120, // Reddish Brown
        "5883C1": 102, // Medium Blue
        "4B974B": 151, // Sand Green
        "A52A2A": 59, // Dark Red
        "B36D2C": 106, // Dark Orange
        "FCB7BC": 104, // Bright Pink

        "60C0E0": 107, // Bright Light Blue
        "FBE696": 103, // Light Yellow
        "84B68D": 37, // Bright Green
        "92B28B": 34, // Bright Yellowish Green
        "002A5A": 140, // Dark Blue
        "DDDD22": 334, // Vibrant Yellow (sometimes 24 is used)
      };

      blockGroups.forEach(function (group) {
        group.traverse(function (child) {
          if (child.isMesh) {
            totalPosition.add(group.position);
            count++;
          }
        });
      });

      blockGroups.forEach(function (group) {
        let mesh_child = null;
        group.traverse(function (child) {
          if (child.isMesh) {
            mesh_child = child;
          }
        });

        if (mesh_child) {
          let ldraw = group.ldraw.replace("parts/", "").replace(".dat", "");
          const boneID = refID;
          let colorID = 21;
            
          if(!mesh_child.material.map && !mesh_child.isLineSegments) {
            const hex = mesh_child.material.color.getHexString().toUpperCase();
            colorID = lego_color_map[hex] ?? 26;
          }
		 
          let adjustedMatrix = mesh_child.matrixWorld.clone();
          
          const globalrot = new THREE.Matrix4().makeRotationX(Math.PI / 1);
          adjustedMatrix.premultiply(globalrot);
          
          const flipmatrix = new THREE.Matrix4().makeRotationX(Math.PI);
          adjustedMatrix.multiply(flipmatrix);
          
          const translationMatrix = new THREE.Matrix4().makeTranslation(-20, 0, 0); // 1 LDU
          adjustedMatrix.multiply(translationMatrix);

          sceneBricks += `
            <Brick refID="${refID}" designID="${ldraw}" itemNos="${ldraw}">
              <Part refID="${refID}" designID="${ldraw}" materials="${colorID},0" decoration="0">
                <Bone refID="${refID}" transformation="${LXFMLMatrix(adjustedMatrix)}"></Bone>
              </Part>
            </Brick>`;

          boneRefs.push(boneID);
          refID++;
        }
      });

      const boneRefString = boneRefs.join(',');

      const sceneData = `
        <?xml version="1.0" encoding="UTF-8" standalone="no" ?>
        <LXFML versionMajor="5" versionMinor="0" name="Imported GR8BRIK Creation">
          <Meta>
            <Application name="LEGO Digital Designer" versionMajor="4" versionMinor="3"/>
            <Brand name="LDD"/>
            <BrickSet version="2670"/>
          </Meta>
		  <Model name="Imported GR8BRIK Creation"></Model>
          <Cameras>
            <Camera refID="0" fieldOfView="80" distance="120" transformation="1,0,0,0,1,0,0,0,1,0,0,120"/>
          </Cameras>
          <Bricks cameraRef="0">
            ${sceneBricks}
          </Bricks>
          <RigidSystems>
            <RigidSystem>
              <Rigid refID="0" transformation="1,0,0,0,1,0,0,0,1,0,0,0" boneRefs="${boneRefString}"/>
            </RigidSystem>
          </RigidSystems>
          <GroupSystems>
            <GroupSystem></GroupSystem>
          </GroupSystems>
          <BuildingInstructions></BuildingInstructions>
        </LXFML>
      `;

      return sceneData.replace(/\s+/g, ' ').trim();
    }

    function LXFMLMatrix(matrix4) {
      const unit = 0.04;
      const converted = matrix4.clone();
	  
	    const rotx = new THREE.Matrix4().makeRotationX(Math.PI / 1);
	  
	    const rot = new THREE.Matrix4();
	    rot.multiply(rotx);
      converted.premultiply(rot);

      const position = new THREE.Vector3();
      const quaternion = new THREE.Quaternion();
      const scale = new THREE.Vector3();
      converted.decompose(position, quaternion, scale);

      position.multiplyScalar(unit);
	    position.x -= 0.8;
	  
      converted.compose(position, quaternion, scale);
      const elm = converted.transpose().elements;

      return [
        elm[0], elm[4], elm[8],    // X
        elm[1], elm[5], elm[9],    // Y
        elm[2], elm[6], elm[10],   // Z
        elm[3], elm[7], elm[11]    // position
      ].map(v => v.toFixed(10)).join(',');
    }

    function updateSceneData() {
	    if (blockGroups && blockGroups.length > 0) {
        blockGroups.forEach(function (g) {
			    g.updateMatrixWorld(true);
          let hasTinyMesh = false;

          g.traverse(function (child) {
				    child.updateMatrixWorld(true);
              if (child.isMesh && isSmall(child, 19)) {
                hasTinyMesh = true;
              }
          });

          g.userData.noSnap = hasTinyMesh;

          /*if (!g.userData.noSnap || !scene.userData.noSnap) {
            g.position.set(
                snapToGrid(g.position.x, 10),
                snapToGrid(g.position.y, 4),
                snapToGrid(g.position.z, 10)
            );
          } */
        });
		    scene.updateMatrixWorld(true);
      }
	  
      if (selectedObject) {
          selectedObject.updateMatrixWorld(true);
      }

      if(scene.children.length != 0) {
        autosave();
      }
  }

  function autosave() {
    const jsonData = generateSceneJSON();
		const date = new Date();
		date.setTime(date.getTime() + (365 * 24 * 60 * 60 * 1000));
		document.cookie = "localsave=" + JSON.stringify(JSON.parse(jsonData)) + "; expires=" + date.toUTCString();
  }

  function read_autosave() {
    const saved = getCookie("localsave");

    if (saved) {
      try {
        const parsed = JSON.parse(saved);
        loadSceneFromJSON(parsed);
        camera.position.x = parsed.camera.x;
        camera.position.y = parsed.camera.y;
        camera.position.z = parsed.camera.z;
        scene.userData = parsed.settings;
        console.log(parsed.camera);
      } catch (e) {
        console.warn("failed to load autosave " + e);
      }
    }
  }

  function clear_autosave() {
    const saved = getCookie("localsave");

    if (saved) {
      try {
        let parsed = JSON.parse(saved);
        parsed.blocks = null;
        parsed.camera = null;
        const date = new Date();
        date.setTime(date.getTime() + (365 * 24 * 60 * 60 * 1000));
        document.cookie = "localsave=" + JSON.stringify(parsed) + "; expires=" + date.toUTCString();

        tooltip('Cleared autosave');
      } catch (e) {
        console.warn("failed to load autosave " + e);
      }
    }
  }

  /* 
  Clone mesh data and not anything like transform controls because idk how to remove it
  */
  /* function clone_mesh_clean(obj) {
      if (!obj.isMesh) { 
        return null;
      }

      const mat = obj.material.clone();
      const geometry = obj.geometry.clone();

      const obj_clone = new THREE.Mesh(geometry, mat);
      obj_clone.position.copy(obj.position);
      obj_clone.rotation.copy(obj.rotation);
      obj_clone.scale.copy(obj.scale);
      obj_clone.name = obj.name;

      return obj_clone;
  } */

  function clone_mesh_clean(obj) {
    if (!obj.isMesh || !obj.geometry) {
      return null;
    }

    let mat;
    if (obj.material) {
      if (Array.isArray(obj.material)) {
        mat = obj.material.map(m => m.clone());
      } else {
        mat = obj.material.clone();
      }
    } else {
      mat = new THREE.MeshLambertMaterial();
    }

    const geometry = obj.geometry.clone();
    geometry.name = obj.name || 'mesh';
    const obj_clone = new THREE.Mesh(geometry, mat);

    obj.updateMatrixWorld(true);
    obj.getWorldPosition(obj_clone.position);
    obj.getWorldQuaternion(obj_clone.quaternion);
    obj.getWorldScale(obj_clone.scale);

    obj_clone.name = obj.name || 'clone';

    return obj_clone;
  }

  /* function normalize_color(color) {
    if(!color) {
      return;
    }

    let r = color.r;
    let g = color.g;
    let b = color.b;

    const max_rgb = Math.max(r, g, b);
    if (max_rgb < 0.1) {
      const boost = 1.0 / max_rgb;
      r = Math.min(1.0, r * boost);
      g = Math.min(1.0, g * boost);
      b = Math.min(1.0, b * boost);
    }

    return new THREE.Color(r, g, b);
  } */

  /*function brighten_color(color) {
    // 0.6 is brightness
    return new THREE.Color(
      Math.max(color.r, 0.6),
      Math.max(color.g, 0.6),
      Math.max(color.b, 0.6)
    );
  } */

  function filter_objects_peices() {
    let thumb = new THREE.Scene();

    scene.traverse(function (object) {
      if (object.isMesh && object.userData.isBlock) {
        const hexColor = object.material?.color || object.material?.map || new THREE.Color(0xffffff);
        let cloned = clone_mesh_clean(object);
        if (cloned) {
          if(cloned.material && cloned.material.color && selectedExport === "dae") {
            apply_vertex_from_hex(cloned, hexColor);
            cloned.material.vertexColors = true;
          } else if (cloned.material && Array.isArray(cloned.material)) {
            cloned.material.forEach(mat => {
              if (mat?.color) {
                mat.color = mat.color.getHexString();
              }
            });
          } else {
            cloned.material = new THREE.MeshPhysicalMaterial({ color: hexColor, metalness: 0, roughness: 1 });
          }
          thumb.add(cloned);
          cloned.rotation.setFromQuaternion(cloned.quaternion);
        }
      }
    });
    return thumb;
  }

  function apply_vertex_from_hex(mesh, hex) {
    const geometry = mesh.geometry;
    const color = new THREE.Color(hex);

    const count = geometry.attributes.position.count;
    const colors = new Float32Array(count * 3);

    for (let i = 0; i < count; i++) {
      colors[i * 3 + 0] = color.r;
      colors[i * 3 + 1] = color.g;
      colors[i * 3 + 2] = color.b;
    }

    geometry.setAttribute('color', new THREE.BufferAttribute(colors, 3));

    if (Array.isArray(mesh.material)) {
      mesh.material.forEach(mat => mat.vertexColors = true);
    } else {
      mesh.material.vertexColors = true;
    }
  }

  function generate_missing() {
    const geo = new THREE.BoxGeometry(10, 10, 10);
    const mat = new THREE.MeshBasicMaterial({ color: 0xff00ff, wireframe: true });
    return new THREE.Mesh(geo, mat);
  }

  /* function updateMaterials() {
    if(!selectedObject) {
      return;
    }

    displayedColors = document.getElementById("obj-colors");
    displayedColors.innerHTML = "";

		selectedObject.traverse((child) => {
			if (child.isMesh && child.material) {
				if (Array.isArray(child.material)) {
          child.material.forEach((mat, index) => {
            console.log(mat);
            if (mat && mat.color instanceof THREE.Color && typeof mat.color.getHexString === "function") {
              const colorHex = `#${mat.color.getHexString()}`;
              const span = document.createElement("span");
              console.log(`Subpart ${index}: ${colorHex}`);
              span.style.backgroundColor = colorHex;
              span.style.padding = "2px 2px 2px 2px";
              displayedColors.appendChild(span);
            }
          });
				}
			}
		});
    updateSceneData();
  } */

    function onMouseClick(event) {
        let target = event.target;
        let container = document.querySelector(".scene");
        const rect = container.getBoundingClientRect();
 
        if (!container.contains(target)) {
            return;
        }

        mouse.x = ((event.clientX - rect.left) / rect.width) * 2 - 1;
        mouse.y = -((event.clientY - rect.top) / rect.height) * 2 + 1;
 
        raycaster.setFromCamera(mouse, camera);
        let intersects = raycaster.intersectObjects(scene.children.filter(obj => obj.visible), true);

        if (intersects.length > 0) {
            selectObject(intersects[0].object);
        } else {
            deselect(selectedObject);
        }
     }
 
     function selectObject(obj) {
        while (obj.parent && !obj.userData.isBlock) {
            obj = obj.parent;
        }
 
        if (!obj.userData.isBlock && transformControls.enabled) {
            return;
        }
 
        if (obj === selectedObject) {
            return;
        }

        transformControls.detach(selectedObject);
		    selectedObject = null;
        
        transformControls.attach(obj);
		    selectedObject = obj;
        
        /* partColor = `#${obj.material.color.getHexString()}`;
        $("#your-color-input").spectrum("set", partColor); */
    }

    function deselect(obj) {
      transformControls.detach(obj);
		  selectedObject = null;
    }

    function onWindowResize() {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
    }

    function moveBlock(mode) {
        if (mode === "t") {
            transformControls.setMode('translate');
            tooltip('Changed to drag blocks');
        }

        if (mode === "r") {
            transformControls.setMode('rotate');
            tooltip('Changed to rotate blocks');
        }

        if (mode === "s") {
            transformControls.setMode('scale');
            tooltip('Changed to secret scale blocks');
        }
    }

    document.getElementById("resetCamera").addEventListener("click", function () {
      camera.position.set(250, 250, 250);
      scene.updateMatrixWorld();
    });

    // Last refactor 6/3/2025 by susstevedev
    function animate() {
      document.addEventListener('DOMContentLoaded', function () {
        const stats = new Stats();

        stats.domElement.style.position = 'absolute';
        stats.domElement.style.zIndex = '99999999';
        stats.domElement.style.left = '0px';
        stats.domElement.style.bottom = '0px';
        document.body.appendChild(stats.domElement);

        setInterval(function () {
          stats.update();
        }, 1000 / 60);
      });

      requestAnimationFrame(animate);
      controls.update();
      //lighting.position.copy(camera.position);
      renderer.render(scene, camera);
      renderer.outputColorSpace = THREE.SRGBColorSpace;
    }

    function tooltip(text) {
        const tooltip = document.createElement('div');

        tooltip.textContent = text;
        tooltip.setAttribute('id', 'tooltip');
        document.body.appendChild(tooltip);

        if (tooltip) {
            setTimeout(() => {
				      tooltip.style.animation = 'toright 0.5s ease-out forwards';
				      setTimeout(() => {
					      tooltip.remove();
				      }, 500);
            }, 5000);
        }
    }

    window.onload = function() {
        setTimeout(() => {
            if (document.getElementById("preloaded-logo")) {
                document.getElementById("preloaded-logo").style.display = "none";
            }
        }, 1000);
    }
  </script>

  <!-- LDRAW.ORG CC BY 2.0 PARTS LIBRARY ATTRIBUTION -->
  <div class="ldraw-logo">
        <a href="http://www.ldraw.org">
            <img style="width: 145px" src="https://threejs.org/examples/models/ldraw/ldraw_org_logo/Stamp145.png">
        </a>
    <br />
    <a href="http://www.ldraw.org/" style="color:#000;">This software uses the LDraw Parts Library &amp; LDrawLoader.js</a>
  </div>

</body>
</html>